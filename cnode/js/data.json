{
success: true,
data: [
{
id: "57cf84508624502e475135ef",
author_id: "4f19795e817ae4105c01cc1f",
tab: "share",
content: "<div class="markdown-text"><h1>发票</h1> <p>先说发票问题，发票问题每年都是JSConf 中国的痛点，作为一个非营利性的野生技术协会，由于组委会自己没有合法的主体，例如合法NGO，所以我们只能依靠其他公司如 Wiredcraft 公司或者其他第三方平台如 售票网站代开发票。所以每年在发票的问题上都会给很多同学造成困扰，对此我谨代表组委会给大家道歉。 而每年我们也都在想办法优化这个流程，希望能够以最简单的方法解决这个问题，对于今年我们的方案是寻求一个合作伙伴帮我们代开发票，然后在会前给我们所有发票，以方便需要发票的同学能够现场取得发票。但是意外时有发生，会前的前一天代理公司告诉我无法提供约定的发票。当时情况我也很愤怒，但是愤怒于事无补，只得竟可能的和代理商沟通积极寻求好的方案，但是结果并不如预期想的那样，我们依然没有取得所有的发票。所以我想再次对想要在会场上拿到发票的同学说声抱歉。 发票的事情我们组委会也并不推卸责任，寻求靠谱的合作伙伴本就是我们的责任，既然事情发生了我们也不推脱，只想积极寻求解决问题。现在的解决方法是：</p> <ol> <li>对于已经打出发票尚未领取的同学，我们这边会电话联系寻求邮寄地址后于两日内寄出。</li> <li>对于尚未打出发票的同学，我们会邮件询问邮寄地址（希望这部分同学可以查看下邮箱），并与本周内寄出（对于这部分同学我们会在 “JSConf 中国 2017” 的大会门票中给予相应的折扣）。</li> </ol> <h1>大会总结</h1> <p>以下内容转载自云栖社区，作者：贺科学 （已得到作者授权） 原文链接，<a href="https://yq.aliyun.com/tags/type_blog-tagid_14321/">https://yq.aliyun.com/tags/type_blog-tagid_14321/</a></p> <p><strong>详细的 keynote/ppt 请到我们的官方网站 <a href="http://2016.jsconf.cn">http://2016.jsconf.cn</a> 下载查看。</strong></p> <h2>9月3日上午</h2> <h3>VUE.js</h3> <h4>讲师</h4> <p>尤雨溪， Vue.js的作者</p> <h4>主题</h4> <ul> <li>progressive framework （其实是说通过多角色的工具库类逐渐补充核心层的能力）</li> <li>core : decirative rendering</li> <li>component system</li> <li>routing</li> <li>large scale state management</li> <li>build system</li> <li>client-server data persistence</li> <li>vue 2.0</li> <li>server bundle -&gt; stream handle</li> <li>virtual dom in vue</li> <li>template =&gt; render function，setting up virtual dom.</li> <li>server side rendering</li> <li>“weex inspired by vue” become “weex powered by vue”</li> <li>vue.js 2.0 acting as the runtime framework for weex</li> <li>writing components which can run both on vue.js and weex, whitch means both web side and native side</li> </ul> <h4>关注点</h4> <ul> <li>从讲师的内容来看未来前端框架（不是前端技术或者web开发的趋势，仅仅是框架的发展趋势）的发展趋势： virtual dom、资源整合与共享（vue与weex的合作）</li> <li>框架演进的思路，渐进式地去完善一个框架，这样可以在各种维度满足各种需求的开发者，因为不同层次的组件都可以使用符合规范的替代品，从而对开发者当前的技术积累和习惯带来尽可能小的影响。</li> </ul> <h4>感想</h4> <p>一个框架从诞生到发展为国内最新最热的前端基础设施，vuejs的成功让人看到了一个开发者的坚持与成长。就这一点而言，对我的触动很大。很多时候也许确实不应该想那么多，先动手做，然后路自然就通了。</p> <h3>HOW TO BUILD A COMPILER</h3> <h4>讲师</h4> <p>James Kyle from Facebook, main contributor of flow and babel</p> <h4>主题</h4> <ul> <li>what is a compiler</li> <li>what dose a compiler do</li> <li>traverse</li> <li>visitor</li> <li>词法分析</li> <li>语法分析</li> <li>抽象语法树</li> <li>parsing</li> <li>transformation</li> <li>code generation</li> <li>code reivew (通过展示代码的方式讲解编译器要做的几件事情以及对应的函数)</li> <li>old ast =&gt; new ast(javascript) (将抽象语法树转换为某种语言的新的抽象语法树，当前代码以JavaScript为例)</li> <li>tokenizer (关键字识别处理)</li> <li>parser token -&gt; ast (识别输入字符串的关键字，生成抽象语法树)</li> <li>traverser ？？TODO: 待订正</li> <li>transformer</li> <li>code generator (生成对应的代码)</li> <li>compiler （将上面的几步编排起来，依次调用，得出最终的结果）</li> </ul> <h4>关注点</h4> <ul> <li>编译器的各个环节的基本业务逻辑，即各个环节“要干什么事情”</li> <li>讲师在开场铺垫时，讲了一些如何学习新技术的经历，可以关注一下</li> </ul> <h4>感想</h4> <p>国外讲师的PPT风格总是会让人耳目一新，也正展现了他作为一个极客放荡不羁、特立独行的一面（红蓝配看久了真的很伤眼……）。在整个讲解如何实现一个编译器的过程中，每个环节都讲得比较清晰，并且结合一个非常简单的代码示例来让听众明白编译器从0到1的过程，做到了深入浅出。编译器的整个处理流程在一些复杂的自定义业务逻辑处理场景中有着非常重要的作用，期待未来能有一个通用编译器，可以让开发者自己定义自己的 语言关键字、语法规则、对应的处理逻辑，这件事可以想象的空间还是很大的，需要对 James 的例子再做一次抽象。</p> <h3>阿里node 团队开源项目，企业级框架EGG</h3> <h4>讲师</h4> <p>天猪 from Alibaba UC Group，eggjs</p> <h4>主题</h4> <ul> <li>nodejs在阿里内部的应用历史与发展历程的介绍</li> <li>EGG定义了若干规范</li> <li>具备强大的插件系统</li> <li>找准了一些企业级web框架应该关注的若干个领域，通过插件机制来针对性地完成支持，从而构建出理想中的企业级应用框架，以下为几个例子：</li> <li>node 实现java 的rpc框架，序列号、反序列化、服务治理等等</li> <li>安全</li> <li>跨语言RPC</li> <li>日志</li> <li>标准的开源社区协作模式</li> <li>workflow</li> <li>ut</li> <li>code style lint</li> <li>开发期辅助</li> <li>痛点的总结和分析，从而推导出合理的做法</li> </ul> <h4>关注点</h4> <ul> <li>企业级应用框架在各个领域需要关注的点，特别是生产环境的安全问题、日常维护与排错过程中需要使用到的日志系统等方面</li> </ul> <h4>感想</h4> <p>其实能知道EGG在开发过程中遇到的各种各样的难题，特别是在与已有的中间件系统做对接，服务发现与治理等方面一定有很多技术闪光点在里面，但是可能是由于时间和主题的限制，这样的技术点讲解的有点泛泛，其实可以减少框架介绍性的陈述，使用关键几个技术核心点来让听者感知到EGG的技术深度。</p> <h3>聊聊 JS 测试框架</h3> <h4>讲师</h4> <p>严清 from Teambition</p> <h4>主题</h4> <ul> <li>开始补充了 toa 的相关feature，基于koa</li> <li>QUIC 在nodejs上的实现：目前正在研发的“下一代协议”</li> <li>链接迁移，移动端切换网络的常见具备实际应用的价值</li> <li>测试框架流派</li> <li>tap</li> <li>tape</li> <li>ava</li> <li>jasmine</li> <li>mocha</li> <li>jest</li> <li>mocha 流</li> <li>tape 流</li> <li>测试框架的核心和补充工具</li> <li>流程控制</li> <li>“新轮子”</li> <li>从外观上看，在原有的mocha基础上，新增对 async/await 、 yield 、observable 三种异步形式的支持。</li> <li>tman</li> </ul> <h4>关注点</h4> <ul> <li>完整的测试框架执行流程的讲解部分</li> <li>运行上下文状态机</li> </ul> <h4>感想</h4> <p>前端的任何一个技术领域深入以后都会有很多很深入的技术细节令人着迷，在开发过程中所遇到的所有的令人困扰的问题在解决之后都会变成让人情绪亢奋的兴奋点，也正是这种感觉让开发人员能够持续而深入地投入到自己所喜爱的事情中去。一件微小的事情，一个细分的技术方向，解决好了，沉入其中，自然会有广阔的天地，相比自己之前的日常工作，浪费了太多的精力和心血在没有价值的事情上。</p> <h2>9月3日下午</h2> <h3>Gridcontrol —— networked process managers</h3> <h4>讲师</h4> <p>Alexandre Strzelewicz, pm2的作者，cto of <a href="http://keymitrics.io">keymitrics.io</a></p> <h4>主题</h4> <ul> <li>PM2</li> <li>originised application</li> <li>ecosystem.json</li> <li>PM2 V2 will be released in September.</li> <li>grid-control</li> <li>multi DNS + DHT</li> <li>wide area discovery (accorss subnet)</li> <li>microservice is hot but hard</li> <li>serverless framework</li> <li>AWS Lambda</li> <li>process manager + network layer</li> <li>networked file system</li> <li>distributed messaging</li> <li>setup a Grid</li> <li>gridfile</li> <li>provisioning</li> <li>grid dash</li> <li>demo time</li> <li>open source on site ### 关注点 解决微服务存在的若干问题的思路: pm2(cpu、线程管理能力) + grid control</li> </ul> <h4>感想</h4> <ul> <li>国外的讲师总能给人以惊喜，Alexandre 在分享现场把 GridControl 开源给我的鼓舞非常巨大，让我感受到了这些开发者在开源之路上体现出的文化以及他们无私分享的精神。</li> </ul> <h3>3D on the web</h3> <h4>讲师</h4> <p>罗诗亚, developer advocate at Autodesk</p> <h4>主题</h4> <ul> <li>graphics pipeline</li> <li>vertex shader (code interactive)</li> <li>primitive assembly</li> <li>rasterization</li> <li>fragment shader（code interactive）</li> <li>freame buffer</li> <li>an easy way for 3D on the web —— three.js</li> <li>scene 、 camera、renderer、controls</li> <li>put a stuff in the scene</li> <li>animate</li> <li>getting started</li> <li>codereview</li> <li>demo show</li> </ul> <h4>关注点</h4> <ul> <li>setTimeout 和 requestAnimationFrame 在浏览器动画渲染中的差别</li> <li>demo演示 和 演示示例背后的技术细节</li> <li>基于three.js的开发所形成的生产力</li> </ul> <h4>感想</h4> <p>图形化的demo非常有感染力，在诗亚展示的若干个示例中，让在场的所有人感受到了web开发在3D图形领域可以做到多么精细酷炫。其实在理想的世界里，抛开商业上的各种考量和顾虑，诗亚以及她所在的团队基于three.js开发的一些功能和效果，如果经过抽象优化后能够开源，相信会给技术社区带来新的活力，特别是结合 web VR，充分利用二者在各自领域的技术优势，前景更让人充满期待。</p> <h3>A-Frame, Building Virtual Reality on the Web</h3> <h4>讲师</h4> <p>Kevin Ngo from Mozilla | <a href="http://mozvr.com">mozvr.com</a> | <a href="http://aframe.io">aframe.io</a></p> <h4>主题</h4> <ul> <li>Virtual Reality</li> <li>传统 VR 和 WEB VR的对比</li> <li><a href="https://w3c.github.io/webvr">https://w3c.github.io/webvr</a></li> <li>metaverse: 虚拟世界</li> <li>magicVoxel</li> <li>entity-component-system (有对应的扩展机制自定义自己的组件)</li> <li>使用VR技术的一些案例 ### 关注点</li> <li>创建webvr的若干步骤</li> <li>a-frame 框架</li> </ul> <h3>感想</h3> <p>听了Kevin的分享，感触最深的是两点，一是听过之前 3D on the web分享之后，再听 web VR 的分享，感觉web开发在目前最新的技术潮流中并没有缺席，反而利用其自身的优势在促进新兴技术的发展；二是在讲解使用WEB VR技术做的一些实际案例中，作品 afraid of sky （部分名称），利用VR技术向世人展示战争的残酷和血腥，呼吁和平。技术也许不能拯救世界，但是可以通过一点点的努力改变世界</p> <h3>Building a Unified Frontend and Mobile Team</h3> <h4>讲师</h4> <p>郭达峰 @上线了: <a href="http://sxl.cn">sxl.cn</a></p> <h4>主题</h4> <ul> <li>关于 react , react native</li> <li>前端UI层的虚拟机，用来屏蔽各端差异</li> <li>react native带来的变革</li> <li>跨端组件差异</li> <li>原生模块的补充 （使用 typescript 定义组件接口，在react中使用）</li> <li>由技术变革引发的团队架构变革（很多情况下，反之也成立）</li> <li>react native 能给以往的组织结构、分工方式带来新的可能性</li> <li>跨端的工程化，代码复用率</li> <li>前端开发发展的另外一个趋势，在适合的业务场景下，融合其他“端”，促进其他 “端”</li> <li>react native 年轻的生态系统</li> <li>第三方库受到react的影响</li> <li>第三方库的不完善</li> <li>打造全端团队需要的成员</li> <li>具备native开发经验</li> <li>好奇心强，愿意深入细节深入源码</li> <li>对未来的一个展望</li> <li>可以预料到的趋势</li> <li>会遇到阻力，来源于现有的组织结构与人员分配 —— 用实践突破困境</li> </ul> <h4>关注点</h4> <ul> <li>围绕移动web产生的一些工具、系统，方便开发者进行移动开发，与原来的前端开发生态相比，更多的人和精力投入到对web开发的支持中。</li> <li>团队建设</li> </ul> <h4>感想</h4> <p>听到这个时候，基本上可以从今年的这些分享中看到未来前端开发技术发展的几个趋势， 多端开发融合在历史包袱不重的团队中会逐渐成为技术选型的主流 开发框架的相互促进、借鉴、合作和相互弥补从而共建技术生态社区也是一个可能的趋势 web开发在可预料的时间范围内会继续利用自身优势涉足热门技术领域，并且丰富相应的技术应用场景</p> <h3>Building asynchronous microservices that get along</h3> <h4>讲师</h4> <p>Makara Wang from Wiredcraft</p> <h4>主题</h4> <ul> <li>微服务</li> <li>微服务的交互</li> <li>restful接口提供服务</li> <li>消息中间件</li> <li>任务系统</li> <li>微服务面临的问题</li> <li>Gateway，单一接入点</li> <li>API解耦 —— GraphQl</li> <li>请求变重</li> <li>API 数量暴增</li> <li>重点介绍</li> <li>原来：（在分布式系统中，原来的方式有限制）</li> <li>现在：</li> <li>事物使用DB保证</li> <li>使用DB锁防止数据冲突</li> <li>使用消息中间件服务</li> <li>CQRS (used with Event Sourcing) Command Query Responsibility Segregation, 命令查询职责分离模式</li> <li>Event Sourcing (事件数据库)，保证最终一致性</li> <li>以订单&amp;支付为例子，讲解遇到的问题如何解决</li> </ul> <h4>关注点</h4> <ul> <li>听众需要自己去判断分享者说的内容是不是对的。</li> <li>要注意分享者说的内容，是不是真的是微服务的关键，或者说，分享者 “拼接”一个微服务的架构出来以后，是不是真的就是微服务了？（需要思考有没有必要，是不是切合业务需求，是不是能解决现有或者未来会出现的问题？）</li> </ul> <h4>感想</h4> <p>讲师后面的技术方案其实在业内是属于比较常见、通用的编程模型，其实没有必要非要往微服务上面靠 。分享后半部分虽然能从问题产生的根源上面来逐步引入解决方案，但是缺失一个总体上的陈述，所以导致听者比较难以跟上节奏。另外限于时间上的限制，很多关键技术点并没有展开讲解，所以听众可以再拿着PPT，针对讲师没有细说的各个技术点自己做下功课，然后去辩证的理解和学习。</p> <h2>9月4日上午</h2> <h3>单页应用“联邦制”实践</h3> <h4>讲师</h4> <p>孙坤鹏， UCloud前端负责人</p> <h4>主题</h4> <ul> <li>Ucloud 大规模单页面应用的一些特性</li> <li>稳定性 —— 2B业务的天然特性</li> <li>灰度 —— 流控、分流</li> <li>遇到的问题</li> <li>多产品灰度，节奏冲突</li> <li>多租户 （其实不是多租户的概念，应该是OEM或者产品定制化的问题）</li> <li>问题的旧的解决方案</li> <li>集中制</li> <li>灰度、稳定版本并行</li> <li>无视产品定制化</li> <li>问题的新的解决方案 —— 联邦制</li> <li>单页面、多应用</li> <li>模块单独治理</li> <li>支撑体系</li> <li>分模块加载机制以及相应的架构支撑</li> <li>动态配置+默认配置+静态配置 =&gt; 合并路由及配置 （failover方案，主要是为了保证任何异常情况下，用户看到的都是可接受的、可用的应用）</li> <li>配置&amp;灰度系统 （关注每个用户都有一个单独配置背后的技术支撑）</li> <li>针对配置的一些优化，包括只输出顶级路由信息，子路由交给静态代码</li> <li>后续规划</li> <li>架构优化调整 （最终实现多版本在线并存，目前受限于angularjs的运行时机制）</li> <li>支撑完善</li> <li>自动化流程 （灰度的自动化）</li> <li>平台化、组件化 （目前和阿里云的技术方案比，尚处于初中级阶段）</li> <li>开放 （通过开放，来帮助面临共同业务场景的团队解决问题）</li> <li>情怀？ =&gt; 招聘！</li> </ul> <h3>关注点</h3> <ul> <li>如何从面临的业务问题一步一步做优化，完善出合理的技术方案来解决困局。</li> </ul> <h3>感想</h3> <p>与UCloud的 联邦单页面业务场景对比，阿里云虽然是 “诸侯” 制，虽然不同的产品有独立的域名独立维护，但是不论在前端方面还是在后端支撑方面其实都面临同样的问题，只是由于产品拆分独立以后，每个产品的规模减小，所以最终只有部分业务线的产品会面临动态按需加载、资源优化等问题，这些问题双方解决的思路也是一致的。在服务端支撑上面，双方的思路也基本一致，包括用户级别的灰度配置、failover方案等等。</p> <h3>前端 DevOps 实践</h3> <h4>讲师</h4> <p>王龑 from OneApm</p> <h4>主题</h4> <ul> <li>公司背景介绍</li> <li>DevOps</li> <li>前端技术栈</li> <li>react</li> <li>es2015</li> <li>webpack</li> <li>cdn</li> <li>讲师做DevOps的前因后果 —— 一次IE排除故障的经历。<strong>（问题本身没什么，主要是解决问题的过程和后续的落地行动。一个问题解决以后其他人都不会再犯同样的问题，才算是真正解决了）</strong></li> <li>DNS记录管理工具 （依然是从日常开发中具体的问题入手，落地解决。这种模式是很好的需求驱动技术进阶的方式）</li> <li>jenkins pipeline 对前端发布流程的自动化和规范化改进</li> <li>DevOps三种方法</li> <li>系统化思考</li> <li>缩短反馈环节</li> <li>持续的实践</li> <li>DevOps的四个支柱</li> <li>文化 （从微小的问题入手，落地解决，逐渐积累）</li> <li>工具 （自动化构建工具）</li> <li>度量</li> <li>分享 （实践、优化、分享，形成良性循环）</li> <li>推广时间 —— 使用 Sentry 监控线上报错 (虽然是软广告，但是开发者应该思考自己的业务线是否应该也有一套这样的线上监控系统，而不是被动等待用户上报问题？)</li> </ul> <h4>关注点</h4> <ul> <li>讲师实际案例中，面对问题时如何做处理，解决问题以后，后续的行动进行落地，把问题彻底解决掉</li> <li>通过微小而有益的改进来不断解决开发过程中遇到的各种问题，从而形成一个比较完善的Dev-Ops期间的工具链</li> <li>devops对应研发生命周期各个阶段的范围图</li> </ul> <h4>感想</h4> <p>其实讲师讲的内容还是属于前端工程化中需要做的一些事情，而前端工程化也确实可以反过来被总结为是 DevOps 在前端开发领域的一个细分。听讲师在分享的时候，可以很清晰地感受到他以及他所在团队在做事时的风格，能把所有有碍于效率提升的各种问题逐渐解决掉，这种执行力是值得学习的。</p> <h3>Node.js在线性能调优与故障排查</h3> <h4>讲师</h4> <p>朴灵 from Aliyun, alinode</p> <h4>主题</h4> <ul> <li>三件事</li> <li>CPU 飙高</li> <li>内存泄漏</li> <li>垃圾回收频繁</li> <li>三个案例—— CPU 问题</li> <li>分析资料：*.cpuprofile</li> <li>收集工具</li> <li>分析工具</li> <li>实际解决思路： 使用异步操作替代阻塞型操作，让计算密集型的逻辑交给nodejs线程池完成，不阻塞web主流程</li> <li>v8-profiler/node-inspector</li> <li>alinode</li> <li>chrome dev tools</li> <li>wrk 压测</li> <li>解决问题：</li> <li>三个案例 —— 内存泄漏</li> <li>分析资料：*.heapsnapshot</li> <li>收集工具</li> <li>分析工具</li> <li>思路：</li> <li>v8-profiler/node-inspector</li> <li>alinode</li> <li>chrome dev tools （heapSnapshot文件过大时，不具备可用性；对于匿名对象也不能精准定位）</li> <li>针对有类名的对象，直接使用 chrome dev tools查看即可</li> <li>针对无类名的匿名对象，分析无类名的对象引用关系</li> <li>解决问题：</li> <li>三个案例 —— GC频繁</li> <li>针对有类名的对象，直接使用 chrome dev tools查看即可</li> <li>针对无类名的匿名对象，分析无类名的对象引用关系</li> <li>alinode GC 分析</li> <li>node --trace_gc --trace_gc_verbose 应用启动文件.js</li> <li>alinode</li> <li>分析资料：gc trace log 或 *.heaptimeline文件</li> <li>收集工具</li> <li>分析工具</li> <li>思路：</li> </ul> <h4>关注点</h4> <ul> <li>通过日常代码规避可能会引起的各种问题</li> </ul> <h4>感想</h4> <p>时间略短，demo略仓促</p> <h3>Learning design patterns from modern JavaScript frameworks</h3> <h4>讲师</h4> <p>Fraser Xu from Envato</p> <h4>主题</h4> <ul> <li>什么是设计模式</li> <li>建筑设计模式</li> <li>软件设计模式</li> <li>JQuery</li> <li>MVC、MV*</li> <li>函数式编程</li> <li>单纯、职责单一的function，一个输入会有对应的固定的输出。</li> <li>高阶函数</li> <li>Type System: typescript 、flow、elm ### 关注点</li> <li>讲师分享中，提到的各种框架的一些编程模式</li> </ul> <h4>感想</h4> <p>其实讲师的分享本身更侧重于基于框架的编程模式，而不是传统的设计模式的讨论与讲解。在开始阶段讲师作了调研，问是不是有人认为函数式编程比面向对象编程更好，调查结论是有些人会举手示意。其实针对这个问题，不应该认为一种编程方式比另外一种编程方式更好，而是要知道各自在不同的领域下都有其优势的方面。其实面向对象也好，函数式编程也好，不要相互排斥，该用面向对象程序设计思维去做产品整体架构的地方，不要在战略上偷懒，觉得短平快就是好的，设计是过度的；该利用函数式编程的优势解决技术细节的地方，也不要觉得函数式编程过于自由，有些是奇技淫巧不入流，而是充分考虑业务场景的需要，把过于自由的一些技巧，规范在可扩展易维护的框架内部，这样各有所长共同发挥出最大的价值。单纯的由于某个原因支持一方、鼓吹夸大一方的价值、以优势比较另外一方的劣势，都是在不负责地引导新人，是基于个人情感的耍流氓。所以要小心有人信誓旦旦地去安利某个编程方式而贬低另外一种编程方式。在我的实际编程工作中，基本上面向对象设计和函数式编程都在利用，而鉴于目前很多前端开发者在面向对象程序设计技能上有欠缺，所以会告诉他们，如何在自己的业务场景中，使用设计模式的思路去写出易扩展易维护的代码。设计模式不关心实现细节，它关心的是实现细节所支撑的业务场景能不能符合开放封闭原则，代码能不能做到职责单一原则。</p> <h2>9月4日下午</h2> <h3>面向未来的自动化测试-Macaca</h3> <h4>讲师</h4> <p>徐达峰, from Alipay</p> <h4>主题</h4> <ul> <li>自动化测试的原因</li> <li>WEB工程化演进节奏越来越快</li> <li>版本分化频繁</li> <li>技术选型趋向于混合</li> <li>虽然传统的自动化测试能够解决一些问题，但是依照目前的业务场景来看还远远不够</li> <li>运行时的测试</li> <li>运行环境差异</li> <li>数据源</li> <li>自动化 即是 软件开发 ？</li> <li>UT、组件测试</li> <li>集成测试</li> <li>功能性测试</li> <li>端到端测试</li> <li>测试金字塔 （以下列出的点由上到下投入依次递减）</li> <li>macaca的由来 ：猴类，敏捷灵动</li> <li>依据w3c webDriver 标准</li> <li>基于nodejs</li> <li>多端运行，设备代理层是关键</li> <li>持续集成</li> <li>Gitlab-CI</li> <li>jenkins</li> <li>Gerrit</li> <li>Travis-CI</li> <li>Reliable , nodejs实现的自主研发</li> <li>性能压测</li> <li>在测试时，即进行相关指标的采集</li> <li>研发周期内的工作流</li> <li>webDriver Cloud，用来做兼容性测试， F2ETest</li> <li>基于游戏框架的应用测试</li> <li>服务端基于nodejs，客户端多编程语言的支持</li> <li>遇到的问题</li> <li>框架的windows兼容性</li> <li>安卓 UTF-7 ?</li> <li>IOS 虚拟化</li> <li>未来：跨三端的自动录入功能</li> <li>macaca 3月12日开源</li> </ul> <h4>关注点</h4> <ul> <li>macaca的分布式主从架构设计</li> <li>研发周期内的工作流</li> <li>F2ETest系统的搭建</li> </ul> <h4>感想</h4> <p>关于自动化测试，公共组件的UT不可少，这是底线，UI集成测试、端到端的场景测试，很难做起来，如果没有专业的测试团队做支持，肯定是步履维艰。这里说的专业的测试团队，一是指技术上专业，引入相关工具、系统，引入标准化的测试流程，二是指专职做测试，能够针对产品的迭代更新对应的case。如果单单靠开发做场景测试，依照目前大多数产品的迭代速度和产品的生命周期，完全来不及，所以开发人员要守住底线，UT保证质量。</p> <h3>Managing Async with RxJS 5 at Netflix</h3> <h4>讲师</h4> <p>Ben Lesh from Netflix</p> <h4>主题</h4> <ul> <li>RxJs 5</li> <li>避免不必要的代码运行，节省计算资源（取决于Netflix自己的业务特征，移动端、视频终端的运行环境）</li> <li>web开发中的几种异步场景</li> <li>ajax</li> <li>user events</li> <li>animation</li> <li>sockets</li> <li>workders</li> <li>callback、promise 的问题</li> <li>回调地狱</li> <li>异步请求的顺序问题在同步流程业务中需要代码保证，并且复杂</li> <li>迭代器</li> <li>Observeable, the “dual” of iterator</li> <li>可以从各种异步场景中创建obverseable对象</li> <li>能够适应各种数字、各种程度的异步延时</li> <li>lazy(非及时执行)</li> <li>可取消的</li> <li>RxJs 的一些示例</li> <li>mergeAll (并行，并保证全部异步操作完成)</li> <li>concatAll （串行，异步操作以顺序完成）</li> <li>switch （并行，单项异步操作完成后即当前异步停止，不再被订阅）</li> <li>RxJs 目前的夸语言情况</li> <li>在线演示 Rxjs 在 自动补全组件中的能力，可以看到在快速输入的情况下，可以取消掉之前的异步请求</li> <li>multiplexed socket 场景下原始开发模式和Rxjs开始的代码对比</li> <li>Rxjs 5 的新特性</li> <li>优点</li> <li>模型化各种场景的异步操作</li> <li>声明式的、表达式</li> <li>模块化</li> <li>覆盖各种异步场景</li> <li>缺点</li> <li>60+ operators</li> <li>学习曲线</li> <li>对同步、一步的疑惑</li> </ul> <h4>关注点</h4> <ul> <li>讲师提到的现有各种异步场景的处理在某些场合下的缺点，例如 promise无法取消、普通异步场景中的“回调地狱”问题。</li> <li>Rxjs所带来的新的编程方式背后的思想</li> </ul> <h4>感想</h4> <p>Rxjs的出现再一次证明了业务推动技术发展这一现象。讲师从自己的业务需求出发，在受到已有异步处理方案的困扰以后通过针对性的改进，开发出了Rxjs。</p> <h3>移动海量服务下基于React的高性能同构实践</h3> <h4>讲师</h4> <p>梁伟盛 Tencent Now 直播，架构师</p> <h4>主题</h4> <ul> <li>简单讲了web开发的发展历程 （从变迁看到0-1再从1-0，引出了服务器直接同构渲染的直接原因）</li> <li>一处编写，到处运行</li> <li>reactjs的出现，使服务端、客户端代码同构成为可能。</li> <li>性能优化</li> <li>从网络层入手，减少web端请求（使用服务端直出）</li> <li>首屏优化，深入业务场景进行非必要数据的切除。</li> <li>使用UDP协议替换TCP</li> <li>使用二进制数据协议（Protocol Buffer）替代以往的json协议</li> <li>故障情况下的failover方案</li> <li>页面功能组件化</li> <li>组件实现降级服务配置化</li> <li>分级缓存机制配合默认数据，一级缓存服务端依赖catch服务，二级缓存使用localStorage</li> </ul> <h4>关注点</h4> <ul> <li>需要听者仔细思考目前的前后端分离和讲师讲的页面直出的辩证的对比关系，即：</li> <li>在讲师所在的直播业务场景（更准确地讲，是移动直播业务场景）中，页面简单，意味着服务端直出页面数据量(或者说html字符串长度)不会太大，数据量带来的网络传输消耗可以抵消甚至是小于以往前后端分离技术方案中的逻辑脚本拉取时间。</li> <li>在普通的企业级单页面应用场景中，页面结构虽然简单，但是首屏数据所构建出的HTML字符串的数据量很大，数据传输时间反而要比先加载纯业务脚本，再拉取数据进行客户端渲染的时间长（具体问题具体分析，多数场景中可能性非常大）。</li> <li>所以听众需要具体分析讲师所讲内容的前提，分析对应业务场景面临的真正问题，做针对性的优化，必要时可以果断抛弃业内通用的技术方案，采取最合适的。</li> <li>讲师在整个性能优化过程中抽丝剥茧步步为营地分析、针对性优化的思路很值得学习。</li> </ul> <h4>感想</h4> <p>讲师讲的内容总体来看非常清晰，能够抽丝剥茧，而且整个优化过程贯穿于整个业务发展的各个周期，对于很多新的业务具有很高的参考价值，可以提前采取相应的技术策略来避免后期的技术债务。</p> <h3>Build a Better App with Mapbox</h3> <h4>讲师</h4> <p>Peter Liu from Mapbox</p> <h4>主题</h4> <ul> <li>Data Source: OpenSteetMap</li> <li>数据量大的情况下，需要合理的数据结构提供 “必需” 的数据</li> <li>vector tiles，不同规模下的地图分成小的切块，每次只更新视图内的数据</li> <li>数据中心的数据更新问题</li> <li>开发套件： studio、vector tiles、Mapbox GL、Satelite、Location APIs、Turf.js(spatial analysis)</li> <li>如何使用开发套件：</li> <li>引入js、css文件</li> <li>初始化地图实例</li> <li>实际案例</li> <li>Bike trip planner : 300+ lines of code (骑行导航、路径规划、可视化海拔)</li> <li>物流系统的配送规划，实时配送状态展示</li> <li>fitness tracking app</li> <li>未来规划</li> <li>MapBox Drive</li> </ul> <h3>关注点</h3> <ul> <li>讲师的实际案例</li> </ul> <h4>感想</h4> <p>讲师的英文非常牛，基本上和native speakers差不多了，是时候把英语口语加强了。</p> <h3>DevTools for the Progressive Web</h3> <h4>讲师</h4> <p>Kenneth Auchenberg from Microsoft</p> <h4>主题</h4> <ul> <li>web 和 web开发，作为讲师主题的上下文。</li> <li>网页形态的变迁</li> <li>互联网到移动互联网的变迁</li> <li>PC端、移动端浏览器的变迁</li> <li>浏览器引擎的变迁</li> <li>网页容器的变迁</li> <li>web assimbliy</li> <li>关于前端开发的思考</li> <li>对前端开发的思考：使用js在服务端推送数据在安卓设备显示消息，那么我们还是前端开发者吗？</li> <li>在这种场景下，开发工具是否跟上了这种变迁节奏？</li> <li>典型的前端调试工作流，中间有大量的重复性的、不流畅的（不流畅是因为在浏览器和编辑器中间多次切换）调试过程</li> <li>引出讲师的主题，让浏览器中的开发者工具和开发者自己的编辑器能够交流沟通</li> <li>演示 Visual Code Editor的debug功能，和Chrome浏览器的互动</li> <li>VS Code 与 chrome、Edge、nodejs交互的架构图</li> <li>VS Code 的调试能力与移动端的系统对接，支持IOS代码调试等等</li> <li>讲师的思考：为什么浏览器需要开发者工具？很多普通用户不懂相关的技术，反而会对误入开发者模式的普通用户造成非常大的困扰甚至是安全隐患</li> </ul> <h4>关注点</h4> <ul> <li>VS Code和浏览器互动体系的架构，chrome 调试协议 + Edge 适配器，来支持chrome和Edge</li> </ul> <h4>感想</h4> <p>讲师的分享非常有启发性，通过自己的问题引发听众的思考。</p> </div>",
title: "JSConf 中国2016 PPT 分享汇总与发票问题",
last_reply_at: "2016-09-27T02:56:52.242Z",
good: false,
top: true,
reply_count: 19,
visit_count: 4676,
create_at: "2016-09-07T03:06:56.918Z",
author: {
loginname: "xeodou",
avatar_url: "https://avatars.githubusercontent.com/u/914595?v=3&s=120"
}
},
{
id: "57e38330f7dea63b0e6ab912",
author_id: "50725bc001d0b80148f48097",
tab: "share",
content: "<div class="markdown-text"><p><img src="//dn-cnode.qbox.me/FmjA3ukkRsJgnkDwzvSvk5GOB6mb" alt="Snip20160922_55.png"></p> <blockquote> <p>很可惜的告诉大家，本次活动报名已满，报名放出几个小时就报满了，只能说大家热情太高，下次报名我们也会尝试收费，以此筛选真正热衷 Node.js 开发的开发者。感兴趣的同学可以加群时刻关注下次活动信息。 另外，如果您想跟大家分享自己的话题，直接联系我，二维码在文章最后。</p> </blockquote> <h3>关于杭州 Node Party</h3> <p><img src="//dn-cnode.qbox.me/FjgxnkWtbwPog29A14OQrzibMJLo" alt="logo (1).png"></p> <p>杭州 Node Party 是由大搜车（Souche Inc.）发起的一个面向 Node.js 爱好者的技术分享聚会，希望能够构建一个持续的分享学习的平台，一起发展 Node.js 生态。</p> <blockquote> <p>大搜车是国内领先的二手车 / 新车服务提供商，主营车源市场 / SAAS 服务 / 金融 / 新车金融 / 后市场服务等，目前车源市场 App 的服务端均由 Node.js 支撑，并在公司内部提供多套基础核心服务。大搜车前端研发部 是本活动的唯一 场地和资金 赞助方。</p> </blockquote> <h3>活动议题</h3> <p>继上次主题活动成功举办之后，一直觉得要把杭州的 Node.js 同仁经常聚集到一起，大家不管是重度使用，还是入门尝试，都可以参与进来，一起交流 Node.js 的使用和发展。所以，之后 杭州 Node Party 将持续的办下去，然后 大搜车 会持续独家赞助此活动的所有支出和场地。</p> <p>上次活动，大搜车运营妹子为大家做了一个印着 Node.js 字样的大蛋糕，还有很多自制饮料。不过好像大家对甜品没有那么的热爱，这次我们会改善一下服务，哈！！</p> <p>活动议题：</p> <ul> <li>Node.js 错误处理相关话题 - 王子亭@<a href="https://leancloud.cn/">LeanCloud</a> （40分钟）</li> <li>创业团队撸 Node - 董必正@<a href="https://www.moveha.com/">Moveha</a>（40分钟）</li> <li>课间小分享 - ADoyle@<a href="http://aliyun.com/">阿里云</a>（10分钟）</li> <li>自由交流。</li> <li>中间 2 次茶歇，吃吃喝喝。</li> </ul> <p>现场会准备足量的喝的和吃的（以及妹子）！希望大家气氛能够自由一些，来听一场不吹牛逼的分享，同时能够认识一群热衷于技术的同道！</p> <h3>时间地点</h3> <p>地址：杭州市余杭区五常大道 175 号（西溪印象城旁） 时间：9 月 25 日（下周日） 下午 1 点半到 5 点</p> <p>人数限制在 80 人以内。</p> <h3>往期回顾</h3> <p>可以关注我们的 Github，star 一下项目，每次分享的 Slide 都会更新在此：<a href="https://github.com/Hangzhou-Node-Party/slides">https://github.com/Hangzhou-Node-Party/slides</a></p> <h4>First Party</h4> <p>Time: 2016-08-07 <a href="https://github.com/Hangzhou-Node-Party/slides/tree/master/1st%20%5BAugust%207%5D:%20Souche%20Inc%20Nodejs%20Open%20Sharing%20Party">照片/视频/Slides</a> Topic:</p> <ul> <li>搜车 Node 进化史 - 芋头@大搜车</li> <li>ORM 那些事儿 - 死月@大搜车</li> <li>Node.js 日志监控方案和实践 - 佳男@大搜车</li> </ul> <h3>关注我们</h3> <p>欢迎加入我们的微信群参与讨论（群已满，请扫描以下二维码添加芋头叔叔微信拉你进群，请注明：公司职位以及请求加入 Node.js 群） <img src="//dn-cnode.qbox.me/Fq5riw9NeftuWkMZnCcesbg5NAu9" alt="qrcode (2).jpg"></p> </div>",
title: "【杭州】Node Party 第二期，9月25日下午，大搜车不见不散",
last_reply_at: "2016-09-27T02:43:42.045Z",
good: false,
top: true,
reply_count: 14,
visit_count: 1442,
create_at: "2016-09-22T07:07:28.465Z",
author: {
loginname: "xinyu198736",
avatar_url: "//gravatar.com/avatar/d00d8e3461257418a62b1cb7abeea85a?size=48"
}
},
{
id: "57e8dca7a61dacb35502be75",
author_id: "542bff0c10ab5791322617c7",
tab: "share",
content: "<div class="markdown-text"><img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty%2FLogo-HD.jpg" width="100" /> <h1>TL; DR</h1> <p>Node party 不仅是一个技术分享的社区，更是一个能让大家发展兴趣，结交朋友的party。</p> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8918.JPG" width="600" /> <blockquote> <p>雪狼 ThoughtWorks 分享 Angular 2 归来记 <a href="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/Angular_2_%E5%BD%92%E6%9D%A5%E8%AE%B0.pdf">下载ppt</a></p> </blockquote> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8913.JPG" width="600" /> <blockquote> <p>悠鹤 蚂蚁金服 基于FLUX架构的项目开发 <a href="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/%E5%9F%BA%E4%BA%8EFLUX%E6%9E%B6%E6%9E%84%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91.pdf">下载ppt</a></p> </blockquote> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8916.JPG" width="600" /> <blockquote> <p>杨疯疯 Freelancer 分享 如何做好技术分享 <a href="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pdf">下载ppt</a></p> </blockquote> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8910.JPG" width="600" /> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8917.JPG" width="600" /> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8914.JPG" width="600" /> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8912.JPG" width="600" /> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8909.JPG" width="600" /> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/16th/pics/IMG_8908.JPG" width="600" /> <h2>下载本次PPT&amp;精彩照片</h2> <pre class="prettyprint"><code>https:&#x2F;&#x2F;git.oschina.net&#x2F;rockq&#x2F;node-party </code></pre><h2>加入 BJ NodeJS Club</h2> <img src="http://7xkeqi.com1.z0.glb.clouddn.com/nodeparty/poster-20160904/Poster_M.png" width="600" /></div>",
title: "NodeParty@北京 #16期总结",
last_reply_at: "2016-09-27T02:41:39.764Z",
good: false,
top: true,
reply_count: 4,
visit_count: 490,
create_at: "2016-09-26T08:30:31.093Z",
author: {
loginname: "Samurais",
avatar_url: "https://avatars.githubusercontent.com/u/3538629?v=3&s=120"
}
},
{
id: "57e9e21f1b81eb081a9b1478",
author_id: "56efaf9802c237a73a1a89a2",
tab: "ask",
content: "<div class="markdown-text"><p>var express=require(“express”); var app=express(); var http=require(“http”).Server(app); var io=require(“<a href="http://socket.io">socket.io</a>”).Server(http);</p> <p>以上代码中Server里参数的含义是什么？有API么？ 我搞不懂为什么要传入这些参数，也找不到相关文档，只知道大家都这么写。</p> </div>",
title: "require("http").Server(app)，server里参数的含义是什么？有API么？",
last_reply_at: "2016-09-27T08:49:53.783Z",
good: false,
top: false,
reply_count: 3,
visit_count: 65,
create_at: "2016-09-27T03:06:07.185Z",
author: {
loginname: "lyt308012546",
avatar_url: "https://avatars.githubusercontent.com/u/10969445?v=3&s=120"
}
},
{
id: "57ea257b3670ca3f44c5beb6",
author_id: "541bf9b9ad60405c1f151a03",
tab: "share",
content: "<div class="markdown-text"><blockquote> <p>微信应用号入门实践之cnode社区版</p> </blockquote> <p>首先感谢cnode社区提供的api，本次实现了简单的cnode社区应用号制作。 实现了数据的读取、展示， 实现了简单的布局， 实现了下一页功能。 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/1.png" alt="首页列表"> <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/2.png" alt="内容详情"></p> <p>下面就说说我做这个的过程，不足之处，请多多指教，只愿为进步。</p> <h2>1.创建项目</h2> <p>首先，在官网下载工具，<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1474887501214">下载地址</a> 我的是选择mac版本0.9.092300。</p> <p>然后跟着官方的<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1474887501301">简版教程</a> 创建一个项目。</p> <h4>注：现在官方的工具支持无appid创建项目。</h4> <h5>1.打开开发者工具，选择“添加项目”</h5> <p><img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/3.png" alt></p> <h5>2.选择无appid，填写地址，创建项目</h5> <p><img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/4.png" alt></p> <h5>3.创建成功，看到默认的Demo项目页面</h5> <p><img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/5.png" alt></p> <h2>2.配置</h2> <p>默认的项目里已经没有关于tabBar的配置信息，所以为了学习，我把这个配置进行了修改。</p> <p>首先关于配置的说明同样来自于<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html?t=1474887501556">官方</a></p> <p>注意：官方的代码有些字段是不一样的，小心被坑。</p> <pre class="prettyprint"><code>{ &quot;pages&quot;:[ &quot;pages&#x2F;index&#x2F;index&quot;, &quot;pages&#x2F;logs&#x2F;logs&quot; ], &quot;window&quot;:{ &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; }, &quot;tabBar&quot;:{ &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;, &quot;text&quot;: &quot;首页&quot; }, { &quot;pagePath&quot;: &quot;pages&#x2F;logs&#x2F;logs&quot;, &quot;text&quot;: &quot;日志&quot; }] } } </code></pre><p>增加了tabBar, 查看调试 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/6.png" alt> 看界面是如此的简陋，为此针对tabBar参考官方说明进行了简单的美化。</p> <pre class="prettyprint"><code> &quot;tabBar&quot;:{ &quot;color&quot;:&quot;#272636&quot;, &quot;selectedColor&quot;:&quot;#80bd01&quot;, &quot;backgroundColor&quot;:&quot;#fff&quot;, &quot;borderStyle&quot;:&quot;white&quot;, &quot;list&quot;:[{ &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;, &quot;text&quot;:&quot;首页&quot;, &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;, &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot; },{ &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;, &quot;text&quot;:&quot;我的&quot;, &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;, &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot; }] } </code></pre><p>效果如图 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/7.png" alt> 最后根据文档，对默认页面的窗口表现进行了修改</p> <pre class="prettyprint"><code> &quot;window&quot;:{ &quot;backgroundTextStyle&quot;:&quot;black&quot;, &quot;backgroundColor&quot;:&quot;#fff&quot;, &quot;navigationBarBackgroundColor&quot;:&quot;#000&quot;, &quot;navigationBarTitleText&quot;:&quot;CNODE 应用号版&quot;, &quot;navigationBarTextStyle&quot;:&quot;white&quot;, &quot;enablePullDownRefresh&quot;:&quot;true&quot; }, </code></pre><p>效果如图 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/8.png" alt> 整体配置文件为</p> <pre class="prettyprint"><code>{ &quot;pages&quot;:[ &quot;pages&#x2F;index&#x2F;index&quot;, &quot;pages&#x2F;logs&#x2F;logs&quot; ], &quot;window&quot;:{ &quot;backgroundTextStyle&quot;:&quot;black&quot;, &quot;backgroundColor&quot;:&quot;#fff&quot;, &quot;navigationBarBackgroundColor&quot;:&quot;#000&quot;, &quot;navigationBarTitleText&quot;:&quot;CNODE 应用号版&quot;, &quot;navigationBarTextStyle&quot;:&quot;white&quot;, &quot;enablePullDownRefresh&quot;:&quot;true&quot; }, &quot;tabBar&quot;:{ &quot;color&quot;:&quot;#272636&quot;, &quot;selectedColor&quot;:&quot;#80bd01&quot;, &quot;backgroundColor&quot;:&quot;#fff&quot;, &quot;borderStyle&quot;:&quot;white&quot;, &quot;list&quot;:[{ &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;, &quot;text&quot;:&quot;首页&quot;, &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;, &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot; },{ &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;, &quot;text&quot;:&quot;我的&quot;, &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;, &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot; }] } } </code></pre><h2>3.制作首页列表</h2> <p>根据官方要求，我在pages文件夹内创建了topics文件夹，并创建了对应了 topics.js、topics.wxml、topics.wxss 三个文件。</p> <h3>1.注册页面</h3> <p>首先在配置文件里注册这个topics,</p> <pre class="prettyprint"><code> &quot;pages&quot;:[ &quot;pages&#x2F;topics&#x2F;topics&quot;, &quot;pages&#x2F;index&#x2F;index&quot;, &quot;pages&#x2F;logs&#x2F;logs&quot; ], </code></pre><p>并且制定tabBar点击跳到对应的topics页面</p> <pre class="prettyprint"><code> &quot;tabBar&quot;:{ &quot;color&quot;:&quot;#272636&quot;, &quot;selectedColor&quot;:&quot;#80bd01&quot;, &quot;backgroundColor&quot;:&quot;#fff&quot;, &quot;borderStyle&quot;:&quot;white&quot;, &quot;list&quot;:[{ &quot;pagePath&quot;:&quot;pages&#x2F;topics&#x2F;topics&quot;, &quot;text&quot;:&quot;首页&quot;, &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my.png&quot;, &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;my_hl.png&quot; },{ &quot;pagePath&quot;:&quot;pages&#x2F;index&#x2F;index&quot;, &quot;text&quot;:&quot;我的&quot;, &quot;iconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list.png&quot;, &quot;selectedIconPath&quot;:&quot;images&#x2F;tabBar&#x2F;list_hl.png&quot; }] } </code></pre><h5>注意：我发现注册页面的顺序会影响到默认显示tabBar的顺序，所以我把<code>&quot;pages/topics/topics&quot;</code>放到了<code>&quot;pages/index/index&quot;</code>的前面</h5> <p>然后编写topics.js</p> <pre class="prettyprint"><code>Page({ data: { title: &#x27;首页列表&#x27; }, onLoad: function () { console.log(&#x27;onLoad by topics&#x27;); } }); </code></pre><p>以及topics.wxml文件</p> <pre class="prettyprint"><code>&lt;view class=&quot;topics-main&quot;&gt; 测试首页列表界面 &lt;&#x2F;view&gt; </code></pre><p>和topics.wxss文件</p> <pre class="prettyprint"><code>.topics-main { background: #f60; height: 100%; } </code></pre><p>最后效果如图 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/9.png" alt></p> <h3>2.创建请求</h3> <p>根据文档<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1474887499445">请求数据</a>，在util文件夹内创建一个api.js文件，专门进行数据请求处理。</p> <pre class="prettyprint"><code>&#x27;use strict&#x27;; var HOST_URI = &#x27;https:&#x2F;&#x2F;cnodejs.org&#x2F;api&#x2F;v1&#x27;; var GET_TOPICS = &#x27;&#x2F;topics&#x27;; var GET_TOPIC_BY_ID = &#x27;&#x2F;topic&#x2F;&#x27;; function obj2uri (obj) { return Object.keys(obj).map(function (k) { return encodeURIComponent(k) + &#x27;=&#x27; + encodeURIComponent(obj[k]); }).join(&#x27;&amp;&#x27;); } module.exports = { &#x2F;&#x2F; 获取列表数据 getTopics: function (obj) { return HOST_URI + GET_TOPICS + &#x27;?&#x27; + obj2uri(obj); }, &#x2F;&#x2F; 获取内容页数据 getTopicByID: function (id, obj) { return HOST_URI + GET_TOPIC_BY_ID + id + &#x27;?&#x27; + obj2uri(obj); } }; </code></pre><p>修改topics.js</p> <pre class="prettyprint"><code>var Api = require(&#x27;..&#x2F;..&#x2F;utils&#x2F;api.js&#x27;); Page({ data: { title: &#x27;首页列表&#x27; }, onLoad: function () { console.log(&#x27;onLoad by topics&#x27;); this.fetchData();&#x2F;&#x2F; 获取数据 }, fetchData: function (data) { &#x2F;&#x2F; 处理参数 if (!data) data = {}; if (!data.page) data.page = 1; wx.request({ url: Api.getTopics(data), success: function (res) { console.log(res); } }); } }); </code></pre><p>效果如图 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/10.png" alt> 成功拿到了数据。</p> <h3>3.完善首页列表</h3> <p>拿到了数据，也能修改界面，那么就直接完善这个首页吧</p> <p>代码就不放了，直接上图 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/11.png" alt> 我认为这里值得说的大概只有loading、循环、传参、下一页和页面跳转了。</p> <h4>1.loading</h4> <pre class="prettyprint"><code> &lt;loading hidden=&quot;{{hidden}}&quot;&gt; 加载中... &lt;&#x2F;loading&gt; </code></pre><p>在topics.wxml中写官方提供的loading组件，根据在topics.js中对hidden值的修改，来触发loading。</p> <h4>2.循环数据，展示列表</h4> <p>文档提供了<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1474887501556">列表渲染</a></p> <p>通过<code>wx:for</code>实现列表的渲染。</p> <h5>注意: 默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。</h5> <pre class="prettyprint"><code>&lt;block wx:for=&quot;{{postsList}}&quot;&gt; &lt;view class=&quot;posts-item&quot; index=&quot;{{index}}&quot; id=&quot;{{item.id}}&quot; catchtap=&quot;redictDetail&quot;&gt; &lt;view class=&quot;author&quot;&gt; &lt;image class=&quot;author-avatar&quot; src=&quot;{{item.author.avatar_url}}&quot;&gt;&lt;&#x2F;image&gt; &lt;view class=&quot;author-name&quot;&gt;{{item.author.loginname}}&lt;&#x2F;view&gt; &lt;view class=&quot;posts-tag hot&quot; wx:if=&quot;{{item.top === true}}&quot;&gt;置顶&lt;&#x2F;view&gt; &lt;view class=&quot;posts-tag&quot; wx:if=&quot;{{item.good === true}}&quot;&gt;精华&lt;&#x2F;view&gt; &lt;view class=&quot;posts-last-reply&quot;&gt;{{item.last_reply_at}}&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;view class=&quot;posts-title&quot;&gt;{{item.title}}&lt;&#x2F;view&gt; &lt;view class=&quot;bar-info&quot;&gt; &lt;view class=&quot;bar-info-item&quot;&gt; &lt;image class=&quot;bar-info-item-icon&quot; src=&quot;&#x2F;images&#x2F;icon&#x2F;reply.png&quot;&gt;&lt;&#x2F;image&gt; &lt;view class=&quot;bar-info-item-number&quot;&gt;{{item.reply_count}}&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;view class=&quot;bar-info-item&quot;&gt; &lt;image class=&quot;bar-info-item-icon&quot; src=&quot;&#x2F;images&#x2F;icon&#x2F;visit.png&quot;&gt;&lt;&#x2F;image&gt; &lt;view class=&quot;bar-info-item-number&quot;&gt;{{item.visit_count}}&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;&#x2F;block&gt; </code></pre><p>附上一个没有样式的列表展现 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/12.png" alt></p> <h4>3.传参，实现tab切换</h4> <p>根据cnode的api可以知道通过tab不同的值，获得到不同标签下的内容列表。</p> <p>所以 在页面的最上面 tab 栏中</p> <pre class="prettyprint"><code> &lt;view class=&quot;top-bar&quot;&gt; &lt;view class=&quot;top-bar-item&quot; id=&quot;all&quot; catchtap=&quot;onTapTag&quot;&gt;全部&lt;&#x2F;view&gt; &lt;view class=&quot;top-bar-item&quot; id=&quot;good&quot; catchtap=&quot;onTapTag&quot;&gt;精华&lt;&#x2F;view&gt; &lt;view class=&quot;top-bar-item&quot; id=&quot;share&quot; catchtap=&quot;onTapTag&quot;&gt;分享&lt;&#x2F;view&gt; &lt;view class=&quot;top-bar-item&quot; id=&quot;ask&quot; catchtap=&quot;onTapTag&quot;&gt;问答&lt;&#x2F;view&gt; &lt;view class=&quot;top-bar-item&quot; id=&quot;job&quot; catchtap=&quot;onTapTag&quot;&gt;招聘&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; </code></pre><p>将id进行定义，通过获取id拿到对应的tab类型。</p> <p>其中<code>catchtap</code>是事件绑定。</p> <p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p> <p>在topics.js获取</p> <pre class="prettyprint"><code> onTapTag: function (e) { var self = this; var tab = e.currentTarget.id; &#x2F;&#x2F; 这里就能获取到不同的tab值了 self.setData({ tab: tab }); if (tab !== &#x27;all&#x27;) { this.fetchData({tab: tab}); } else { this.fetchData(); } }, </code></pre><h4>4.下一页的实现</h4> <p>根据文档，组件的视图容器中有<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html?t=1474887496374">scroll-view</a>这个可滚动视图区域。</p> <h5>注意：使用竖向滚动时，需要给&lt;scroll-view/&gt;一个固定高度。</h5> <pre class="prettyprint"><code>&lt;scroll-view class=&quot;posts-list&quot; style=&quot;height:100%&quot; scroll-y=&quot;true&quot; bindscrolltolower=&quot;lower&quot;&gt; &lt;block wx:for=&quot;{{postsList}}&quot;&gt; ... &lt;&#x2F;block&gt; &lt;&#x2F;scroll-view&gt; </code></pre><p>topics.js文件</p> <pre class="prettyprint"><code> lower: function (e) { var self = this; &#x2F;&#x2F; 修改当前页码 self.setData({ page: self.data.page + 1 }); &#x2F;&#x2F; 判断当前页的tab值 进行请求数据 if (self.data.tab !== &#x27;all&#x27;) { this.fetchData({tab: self.data.tab, page: self.data.page}); } else { this.fetchData({page: self.data.page}); } } </code></pre><h4>5.跳页的实现</h4> <p>在<code>posts-item</code>中已经进行了事件绑定。利用<code>wx.navigateTo</code>实现页面的跳转。</p> <h5>注意：一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。</h5> <pre class="prettyprint"><code>redictDetail: function (e) { console.log(&#x27;我要看详情&#x27;); var id = e.currentTarget.id, url = &#x27;..&#x2F;detail&#x2F;detail?id=&#x27; + id; &#x2F;&#x2F; 这里的detail是需要创建对应的文件，以及页面注册的 wx.navigateTo({ url: url }) }, </code></pre><h3>4.实现详情页</h3> <p>同样的原理，创建detail文件，并注册，获取数据，并美化页面。 <img src="http://7xqxfk.com1.z0.glb.clouddn.com//xiaoyingyong/cnode/13.png" alt></p> <h3>5.总结</h3> <ul> <li>微信小应用页面的脚本逻辑在是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能再脚本中使用window，也无法在脚本中操作组件</li> <li>同样不能用jquery</li> <li>也不能操作dom</li> <li>部分标签不支持，比如 h1-h6 会编译报错。</li> <li>暂时没找到解决富文本详情页显示的办法。</li> <li>整体下来，感觉开发简单，限制很多。</li> <li>写过react的看这个确实比较简单。</li> </ul> <p>放上我的github地址 <a href="https://github.com/coolfishstudio/wechat-webapp-cnode">https://github.com/coolfishstudio/wechat-webapp-cnode</a></p> <p>最后感谢：cnode社区和博卡君</p> <p>附上 博卡君的教程</p> <p><a href="https://my.oschina.net/wwnick/blog/750055">全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p> <p><a href="https://my.oschina.net/wwnick/blog/750495">博卡君的应用号（小程序）开发教程首发第二弹！（0923）</a></p> <p><a href="https://my.oschina.net/wwnick/blog/750974">第三弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p> <p><a href="https://my.oschina.net/wwnick/blog/751826">第四弹！全球首个微信应用号开发教程！通宵吐血赶稿，每日更新！</a></p> </div>",
title: "分享我用cnode社区api做微信小应用的入门过程",
last_reply_at: "2016-09-27T08:45:45.829Z",
good: false,
top: false,
reply_count: 14,
visit_count: 275,
create_at: "2016-09-27T07:53:31.872Z",
author: {
loginname: "coolfishstudio",
avatar_url: "https://avatars.githubusercontent.com/u/8791709?v=3&s=120"
}
},
{
id: "57e939a51b81eb081a9b1451",
author_id: "57e9373856898f231a526f86",
tab: "share",
content: "<div class="markdown-text"><p>业余时间写了这个项目，简单演示了如何使用<strong>Express 4.x</strong> + <strong>MongoDb</strong> 实现Web应用最基本的增删改查功能。欢迎大家学习参考交流指正。</p> <p><strong>项目截图：</strong> <img src="//dn-cnode.qbox.me/FmS-nicwVihyQz9KhovBx5a7aWnT" alt="screenshots-01.jpg"> <img src="//dn-cnode.qbox.me/FqgO6F1EkrN3bbS0zISvG64neLGF" alt="screenshots-02.jpg"> <img src="//dn-cnode.qbox.me/Fgo0jHtEdsXWFUcpQHF2-567vPxA" alt="screenshots-03.jpg"></p> <p><strong>项目地址：</strong> <a href="https://github.com/liuxuanqiang/Express_MongoDb_Demo">https://github.com/liuxuanqiang/Express_MongoDb_Demo</a></p> </div>",
title: "Express 4.x 与 MongoDb 实现CRUD",
last_reply_at: "2016-09-27T08:44:40.238Z",
good: false,
top: false,
reply_count: 4,
visit_count: 157,
create_at: "2016-09-26T15:07:17.045Z",
author: {
loginname: "liuxuanqiang",
avatar_url: "https://avatars.githubusercontent.com/u/8065215?v=3&s=120"
}
},
{
id: "57de5c27c4ae8ff239776cf3",
author_id: "57de06085710e2ed658d6bd4",
tab: "ask",
content: "<div class="markdown-text"><p>如题，求视频学习文件！</p> </div>",
title: "求express +nodejs 的学习视频！",
last_reply_at: "2016-09-27T08:43:11.408Z",
good: false,
top: false,
reply_count: 18,
visit_count: 1948,
create_at: "2016-09-18T09:19:35.434Z",
author: {
loginname: "duzitengg",
avatar_url: "https://avatars.githubusercontent.com/u/21256522?v=3&s=120"
}
},
{
id: "57e5e98c2528eed904783f35",
author_id: "54009f5ccd66f2eb37190485",
tab: "share",
content: "<div class="markdown-text"><p><a href="https://github.com/nodejs/node/milestone/15?closed=1">https://github.com/nodejs/node/milestone/15?closed=1</a></p> <blockquote> <p>We did change the naming of v6 from Stable to Current as well, so I am assuming that v7 will also be named as “Current” vs “Stable”</p> </blockquote> <ul> <li>已完成v8 5.4版本集成，也就是说支持async/await</li> <li>koa 2.x也将随之发布，妈妈再也不担心我用bable的async/await调试了</li> <li>upgrade libuv to 1.10.0</li> <li>using openssl 1.1.0</li> </ul> <p>这个国庆节，又要(｡･∀･)ﾉﾞ嗨了</p> <p>异步流程async/await终于落地了</p> <h2>以前</h2> <p><img src="//dn-cnode.qbox.me/FmbZcLrkY4ThT1yQoV9vnyPfioDV" alt="all.png"></p> <h2>以后</h2> <p><img src="//dn-cnode.qbox.me/FsP2jIneBIpGukP8pNW4ez7ps0qF" alt="suggest.png"></p> <p>如果看不懂就请看这篇教程</p> <ul> <li>《深入浅出js（Node.js）异步流程控制》 <a href="https://github.com/i5ting/asynchronous-flow-control">https://github.com/i5ting/asynchronous-flow-control</a></li> <li>《Node.js最新技术栈之Promise篇》<a href="https://cnodejs.org/topic/560dbc826a1ed28204a1e7de">https://cnodejs.org/topic/560dbc826a1ed28204a1e7de</a></li> </ul> <p>全文完</p> <p>欢迎关注公众号【node全栈】</p> <p><img src="//dn-cnode.qbox.me/FtALxsauUkYDGdzcuA5y6BaIdUMC" alt="node全栈.png"></p> </div>",
title: "Node.js 7.0预计在9月30日发布，支持async/await，Koa 2.x也将随之发布",
last_reply_at: "2016-09-27T08:41:21.372Z",
good: false,
top: false,
reply_count: 36,
visit_count: 1214,
create_at: "2016-09-24T02:48:44.144Z",
author: {
loginname: "i5ting",
avatar_url: "https://avatars.githubusercontent.com/u/3118295?v=3&s=120"
}
},
{
id: "57e91dcd1b81eb081a9b1449",
author_id: "5775db7ea998f02050029192",
tab: "ask",
content: "<div class="markdown-text"><p>准备用 nightmare 写自动化测试. 遇到了一个解决不了的问题, 多方查找无果,尝试来 node 社区咨询下: 一个待测试的页面的 window 对象挂了一个方法,方法被调用会改变页面,并返回一个对象. 需求是, 用 nightmare 调用一次这个方法,然后截一次图. 我的实现代码如下:</p> <pre class="prettyprint language-js"><code>var Nightmare = require(&#x27;nightmare&#x27;), nightmare = Nightmare(); nightmare.goto(&#x27;http:&#x2F;&#x2F;127.0.0.1&#x2F;demo&#x27;); nightmare .wait(5000) .run(function(){ nightmare.evaluate(function(){ return window.a.playNextFrame({toggle: true, pId: null}) }) .then(function(result){ console.log(result) nightmare.screenshot(&#x27;&#x2F;test.png&#x27;) .end() }) }) </code></pre><p>但是代码运行结果是: <img src="//dn-cnode.qbox.me/FjNywyedmxuTbr3R4L5Hv4UfBhP-" alt="Screen Shot 2016-09-26 at 20.48.49.png"> 只输出了 result, 并没有生成截图文件 但是按照这种方式,却可以正常生成图片,并打印标题:</p> <pre class="prettyprint language-js"><code>nightmare.goto(&#x27;http:&#x2F;&#x2F;127.0.0.1&#x2F;demo&#x27;) .wait(5000) .screenshot(&#x27;&#x2F;test.png&#x27;) .evaluate(function(){ return document.title; }) .end() .then(function(title){ console.log(title); }) </code></pre><p>请教各位,问题出在哪里? 先谢过了</p> </div>",
title: "nightmare 截图问题",
last_reply_at: "2016-09-27T08:39:58.170Z",
good: false,
top: false,
reply_count: 5,
visit_count: 144,
create_at: "2016-09-26T13:08:29.527Z",
author: {
loginname: "songabc",
avatar_url: "https://avatars.githubusercontent.com/u/10276355?v=3&s=120"
}
},
{
id: "57dd5a1b3f3cb94e6b326828",
author_id: "576661e3197e9a676dff4711",
tab: "ask",
content: "<div class="markdown-text"><p>#最近一直处于秋招的季节，楼主作为一名普通本科生，同时是一个跨专业找工作的大四狗，这段时间应该是超级超级忙，也是超级超级紧张。</p> <h3>非计算机专业学生，找工作，真的感觉前路艰辛。。。</h3> <pre class="prettyprint"><code>楼主在湖南株洲，处在中部地区，学校的资源是有点少的可怜，每次到了校招季来学校的好公司真的是少之又少，一方面这里只有我们一所本科，好多好公司都不愿意到这里过来，另一方面学校名气不够，还不足够吸引好公司来我们这里招聘。 楼主乃某本科大学电子信息工程专业学生，专业课程主要有电子设计及其自动化（EDA），嵌入式，数模电 ，单片机，信号与系统，高频电子电路，数字信号处理等一系列高难度科目，奈何楼主对这些科目真的有点不感冒，加之大一的时候没有把握住转院的机会，于是在大二一开始的时候踏上了web开发的学习之路。 楼主大二开始学习JAVA，期间同十几位同学参与了本地一个电气公司的电商平台的开发，直到最后项目上线。之后由于学校要安排我们专业到广东那边进行“生产实习”（其实就是去进行苦力劳作），当时有一个比较好的机会，一家无人机开发公司刚好需要找实习，于是我就投了简历，想面试一个开发岗，接到了电话面试之后，一开始聊得挺high得，在中途面试官问我有没有使用过node.js,之前有听说过node.js只知道很火，但是并没有学习以及使用过，之后也有一些方面没有发挥好，所以这个实习的岗位也就不了了之了。 之后我就开始了node.js的学习，到现在node.js学习了大概半年，熟悉使用express框架以及koa框架，跟完了慕课网上面的所有课程，也读了几遍朴灵的深入浅出系列，使用node开发了一个简单的微信公众号。学习node的过程中被它的高效及强大所吸引，故想之后成为一名node.js开发工程师。看了看社区的一些招聘，招聘node开发的都需要几年的开发经验，也基本上没有需要开发实习生的。所以想在校招季进一家大公司看有没有机会从事node开发。 进大公司笔试环节需要考的东西真的蛮多，由于公司招聘里面都没有node开发这一项，所以在投简历的时候基本上投的前端开发这一项，有时候没有的话就投软件开发。于是我就开始了苦逼的刷题之路，每天都泡在牛客网上刷题，学习数据结构以及算法，还好之前有C的基础，但仅仅是这些根本不够，笔试里面还有好多智力题，很多题目根本都不知道是个什么鬼，还有一些机器学习之类的题目，简直一脸懵逼，另外因为还需要考到linux，于是又在日程表里多了一项linux的学习。。。做这里面的题目简直想吐血，很多题目的知识点根本都没见过，于是就给自己埋了坑，一点一点慢慢填。 这些天陆陆续续参加了阿里，腾讯，网易，京东的笔试，真的，不做这些公司的面试题，根本就不知道自己有多傻逼，面对题目懵逼，宛如一个智障。今天，又参加了携程的笔试，投的前端工程师，本以为和其他公司一样很多题目都是数据结构算法之类的，可是。。。真的就都是前端啊，除了一些关于js,css，以及概率的题目之外，其他的题目都是什么鬼，不是智力题就是前端的优化。。。555，我只是单纯的想找一个node开发的工作啊，真的心累，难不成又要我回去好好学习前端的设计什么的么？ 找工作真的好累！！！顺便问一句，哪里招node开发，请让我试试。</code></pre></div>",
title: "心好累，难道校园招聘里面就没有node.js的岗位么？",
last_reply_at: "2016-09-27T08:09:20.342Z",
good: false,
top: false,
reply_count: 26,
visit_count: 1871,
create_at: "2016-09-17T14:58:35.330Z",
author: {
loginname: "xiaoyuervae",
avatar_url: "https://avatars.githubusercontent.com/u/19305379?v=3&s=120"
}
},
{
id: "57bc1443dcaeb5d932db22cc",
author_id: "55324cfa1b9662da568db910",
tab: "job",
content: "<div class="markdown-text"><p><strong>深圳点猫科技有限公司 — “玩”成工作</strong> <a href="http://"></a> <a href="https://www.codemao.cn">点我,让你看我们在做什么</a></p> <p>前端全职参考:</p> <ol> <li>熟练：css,html,javascript</li> <li>熟悉：webpack,gulp,typescript,react,flux,redux,git flow</li> <li>知道：cors,domain</li> </ol> <p>后端全职参考：</p> <ol> <li>熟练：nodejs,linux,mysql,http/https</li> <li>熟悉：nginx,git flow,redis</li> <li>知道：docker</li> </ol> <p>实习生对技术深度无要求。 注：</p> <ol> <li>实习生我们免费提供住宿，公司请了4位阿姨做饭帮洗衣服，中晚包餐(阿姨是酒店的星级大厨)。</li> <li>我们的CTO是瑞典人。公司有很多国外留学回来的小伙伴(我们不看学历)。氛围开放</li> <li>上班时间不打卡 10：00～7：00 (我一般是在公司玩到晚上9点才回家)</li> <li>公司离高新园地铁站步行10分钟 Mac/外星人 硬件上都是标配。团队年轻,机会多。</li> </ol> <p><strong>薪资可参考拉钩网招聘(拉钩搜索&quot;编程猫&quot;)。我是公司的技术,下面有我的微信,感兴趣的可以叫我微信聊</strong></p> <p><img src="//dn-cnode.qbox.me/FgmFvKBLQuez2lGgn768oDSF0DY8" alt="WeChat_1471943356.jpeg"></p> <p><img src="//dn-cnode.qbox.me/FoPi5a0IPk16-0KXutm5fzyHuz21" alt="WeChat_1471943359.jpeg"></p> <p><img src="//dn-cnode.qbox.me/FsFx_8P8OkkZ5iXV42cGay-DiKmv" alt="WeChat_1471943361.jpeg"></p> <p><img src="//dn-cnode.qbox.me/Fr1cxUrlu5qMSxyGeF28MLPY47QV" alt="WeChat_1471943364.jpeg"></p> <p>符合条件的可以加我微信 <img src="//dn-cnode.qbox.me/FnfwyPSwE9AC8YGGSjeMvq5s60iT" alt="WechatIMG1.jpeg"></p> </div>",
title: "[深圳大冲] [附图]编程猫 15k-20k 招聘web前端/node后端 实习,应届,全职",
last_reply_at: "2016-09-27T08:08:15.724Z",
good: false,
top: false,
reply_count: 14,
visit_count: 1488,
create_at: "2016-08-23T09:15:47.275Z",
author: {
loginname: "bugall",
avatar_url: "https://avatars.githubusercontent.com/u/8531791?v=3&s=120"
}
},
{
id: "57e891351e1508eb554f2a0a",
author_id: "56d6ad0ebc28a31e7735e7b5",
tab: "ask",
content: "<div class="markdown-text"><p>业务场景是这样的：我有一个函数 getValue()，从redis里面取值，如果有则返回（getValue貌似也要封装成Promise。。。），如果没有则用request去取然后再返回值。可是 request返回的值是在回调函数里面执行的，所以getValue如何同步返回回调函数里面的值呢？</p> </div>",
title: "Node的异步转同步操作，还是觉得满足不了需求啊。。。。",
last_reply_at: "2016-09-27T07:53:26.964Z",
good: false,
top: false,
reply_count: 10,
visit_count: 248,
create_at: "2016-09-26T03:08:37.515Z",
author: {
loginname: "jkiss",
avatar_url: "https://avatars.githubusercontent.com/u/3231326?v=3&s=120"
}
},
{
id: "57ce62b38039ce124769798f",
author_id: "57ce426a8624502e47513581",
tab: "ask",
content: "<div class="markdown-text"><p>res.send(200,json) 在后台用http去请求别人开放的API后,在把数据自己得数据库做数据处理,在返回时IE接收不到数据,但是谷歌可以接收返回json数据。这是不去请求API直接请求自己得数据库IE也可以返回数据了. PS:断点调试发现数据在最后一步res.send(200,json)时卡住，node进程阻塞了再也无法访问系统，而数据在发送,但是前台就是接受不到</p> </div>",
title: "res.send(200,json) IE接收不到,但是谷歌可以接收返回json数据",
last_reply_at: "2016-09-27T07:49:45.651Z",
good: false,
top: false,
reply_count: 4,
visit_count: 279,
create_at: "2016-09-06T06:31:15.539Z",
author: {
loginname: "mllGitHub",
avatar_url: "https://avatars.githubusercontent.com/u/8679085?v=3&s=120"
}
},
{
id: "54afa85cce87bace2444ce44",
author_id: "4f50e82198766f5a610bbaff",
tab: "share",
content: "<div class="markdown-text"><p>nodejs导出Excel, Excel模板引擎 BI商业智能报表系统 通过Excel模板导出Excel npm install ejsexcel 安装nodejs之后,执行test目录下面的test.bat</p> <p>auto: Sail 黄智勇 QQ: 151263555 QQ群: 470988427 email: <a href="mailto:151263555@qq.com">151263555@qq.com</a> <a href="https://github.com/sail-sail/ejsExcel">https://github.com/sail-sail/ejsExcel</a> <a href="http://git.oschina.net/ccteams/ejsExcel">http://git.oschina.net/ccteams/ejsExcel</a></p> <p>模板: <img src="//dn-cnode.qbox.me/Frs_RuLXJxYQgYoIUhGJJ1zspCJE" alt="1.png"></p> <p>加数据渲染之后: <img src="//dn-cnode.qbox.me/FnRDa5Zyjg-dI7ykCNR0T8SorWyC" alt="2.png"></p> <p>捐赠鼓励支持此项目: <img src="//dn-cnode.qbox.me/FucPKV4XWewhakoqTSngU3AsaP0Z" alt="捐赠鼓励支持此项目"></p> </div>",
title: "nodejs报表Excel模板引擎",
last_reply_at: "2016-09-27T07:42:57.098Z",
good: false,
top: false,
reply_count: 51,
visit_count: 10945,
create_at: "2015-01-09T10:07:24.883Z",
author: {
loginname: "151263",
avatar_url: "//gravatar.com/avatar/595ec965d51c7e3c6a7d1e8eb177dd8d?size=48"
}
},
{
id: "57d1ba4a49e399fd386e18fe",
author_id: "569378273b33070b66270a2b",
tab: "job",
content: "<div class="markdown-text"><p>我在2015年11月入职杭州云片网络科技有限公司。</p> <p>于2016年7月被离职。</p> <p>刚刚入职的时候，我在杭州总部呆了半年之久，因为这家公司在我入职时，运营工作基本没有人做，招到我之后我成为了主管运营部门的第一个人。</p> <p>就我一个人负责那么多事情，我申请再招一个同事分担工作还是被拒，那个时候天天加班。</p> <p>加班的时候老板还说晚上技术部门那么就早走肯定有问题的。呵呵。</p> <p>这样我还在杭州多付了六个月的房租。</p> <p>公司的工作时间隔周周六加班，我不知道一个创业公司在周六有什么好加班的事情。</p> <p>办公室的网络也不知道哪里租的黑宽带，时常卡的网站没一个上的去，还是用自己的手机流量完成自己手上的工作。一个网络公司连网都上不去真是笑死我了。</p> <p>老板的微信朋友圈分享基本都是鸡汤小故事，要么就发鸡汤书让员工写读后感，不写的扣工钱。</p> <p>之后回到上海办公室工作，公司还玩双重标准，杭州那边有饭贴，上海这边员工一分钱都没有，开始说的 福利待遇 根本做不到。</p> <p>周末的各种线下活动我也尽力去参加帮助推广企业的产品。</p> <p>在职期间线下活动的资金都是我自己一个人出的，但离职之后一个多月才要到属于我的报销。</p> <p>我之前负责和其他第三方企业谈的合作内容，就差签合同了，到最后还是批不下来单方面拒签，弄的这些合作商很尴尬，云片简直毫无信誉。</p> <p>公司前五十个人数数有几个人拿到期权了，你们只是去打个工而已，所有的利益都是老板自己的。</p> <p>最后还被一个没什么用，连自己本职工作都做不好的『老员工』强迫更改我的工作地点逼我离职。</p> <p>被离职之后，我一分钱赔偿没有，但我也不需要，我知道拿不到的，我觉得能拿到我之前的那些报销已经不错了。</p> <p>之后老板还说之前没招你们的时候公司不也就这样吗，旁边的员工也看看他不说话。</p> <p>看看现在多少员工自己走了，整个运营部门的人都走完了。</p> <p>反正你走了，老板还会招新的人，恶性循环，拿钱不做事的『老员工』已经在公司里为非作歹。</p> <p>一个创业公司一个月盈利三百万，还这样压榨员工，药店碧莲？</p> <p>听说g20杭州企业都放7天假，为什么你们不放？这样违背政府规定真的好吗？</p> <p>拿员工当人了？创业公司？呵呵。</p> <p>无德无信。</p> <p>这家公司除了云片，其他的产品有 淘维、维客、美店。</p> <p>抵制黑心企业的所有产品，防止更多人被坑。</p> <p>更多信息见 <a href="https://yunpian.org">https://yunpian.org</a></p> </div>",
title: "[杭州] 曝光一家黑心企业 杭州云片网络科技有限公司",
last_reply_at: "2016-09-27T07:36:42.560Z",
good: false,
top: false,
reply_count: 7,
visit_count: 417,
create_at: "2016-09-08T19:21:46.989Z",
author: {
loginname: "akar1nchan",
avatar_url: "https://avatars.githubusercontent.com/u/2175497?v=3&s=120"
}
},
{
id: "57e94f1c0424cced19b35cac",
author_id: "574a7fa8fd93c1011f94ac3b",
tab: "share",
content: "<div class="markdown-text"><p><a href="http://www.johnson77.cn">www.johnson77.cn</a> 最近在成都忙着找前端的实习工作，累啊~</p> <p>来自酷炫的 <a href="https://github.com/TakWolf/CNode-Material-Design">CNodeMD</a></p> </div>",
title: "用node做了个小网站，还在完善...",
last_reply_at: "2016-09-27T07:30:13.887Z",
good: false,
top: false,
reply_count: 25,
visit_count: 349,
create_at: "2016-09-26T16:38:52.480Z",
author: {
loginname: "NoJsJa",
avatar_url: "https://avatars.githubusercontent.com/u/19613878?v=3&s=120"
}
},
{
id: "52090bc944e76d216af25f6f",
author_id: "51413e29069911196d4757c9",
tab: "share",
content: "<div class="markdown-text"><h1>Node.js下自定义错误类型</h1> <p>在JavaScript里面，运行过程中的错误的类型总是被人忽略，这篇教程主要从三个方面来介绍如何在Node.js下自定义错误类型。</p> <ul> <li>为什么要使用错误对象。</li> <li>怎么创建自定义错误对象。</li> <li>一些自定义错误对象的例子。</li> </ul> <h2>为什么要使用错误对象</h2> <p>一般来说，很少人会考虑如何处理应用产生的错误的策略，调试的过程中，简单地利用console.log(‘error’)定位错误，基本够用了，通过留下这些调试信息，能够为我们以后的调试过程中升了不少时间，提高了维护性。所以错误提示非常重要。同时，也会带来一些比较糟糕用法。</p> <h3>糟糕的字符串错误提示</h3> <p>Guillermo Rauch 曾经写了<a href="http://www.devthought.com/2011/12/22/a-string-is-not-an-error/">一篇优秀的文章</a>解释为什么最好不要用字符串作为错误调信息，以下是一种常见的错误处理方式</p> <p>if (id &lt; 0) return ‘id must be positive’</p> <p>直接返回错误字符串信息，虽然很简单，但是项目大了，就不好维护了，会产生以下这几个问题。</p> <h4>很难知道错误在哪里发生的？</h4> <p>除非你的打印字符串里面，包含了文件和代码的行数，要不然，你根本不知道错误在哪里发生的。</p> <p>####不能处理不同类型的错误</p> <p>如果全部都是使用字符串作为错误提示，在运行的过程中，很难针对不同类型的错误进行不同的处理，有时候我们需要针对不同的错误进行不同类型的处理，如提交表单信息错误，数据库类型错误等。</p> <h2>系统错误对象</h2> <p>利用系统自带的错误类型来代替纯字符串的错误提示</p> <pre class="prettyprint"><code>if (id &lt; 0) return new Error(&#x27;id must be positive&#x27;) </code></pre><p>尽管看上去只是多了一点小步骤，但实际上却带了了很多好处。</p> <h3>获取错误在哪里发生</h3> <p>如果用了错误，对象会产生堆栈属性，通过执行文件，通过行号，查找到出错的地方。</p> <pre class="prettyprint"><code>console.log(error.stack) Error: An error occurred at Object.&lt;anonymous&gt;(&#x2F;Users&#x2F;ds&#x2F;main.js:1:73) at Module._compile (module.js:441:26) at Object..js (module.js:459:10) at Module.load (module.js:348:31) at Function._load (module.js:308:12) at Array.0 (module.js:479:10) at EventEmitter._tickCallback (node.js:192:40) </code></pre><h3>获取错误类型</h3> <p>可以通过Instanceof 来检查错误类型，根据类型进行不同的处理</p> <pre class="prettyprint"><code>if (err instanceof DatabaseError) { &#x2F;* do this *&#x2F; } if (err instanceof AuthenticationError) { &#x2F;* do that *&#x2F; } </code></pre><h2>如何创建一个自定义的错误对象</h2> <p>通过对错误对象的继承与复写的手段，创建一个自定义的错误对象。</p> <h3>抽象错误对象类型</h3> <p>创建一个抽象的错误类基类</p> <pre class="prettyprint"><code>var util = require(&#x27;util&#x27;) var AbstractError = function (msg, constr) { Error.captureStackTrace(this, constr || this) this.message = msg || &#x27;Error&#x27; } util.inherits(AbstractError, Error) AbstractError.prototype.name = &#x27;Abstract Error&#x27; </code></pre><h3>定义数据库错误对象</h3> <p>利用上述创建的抽象错误类型，扩展到其他自定义错误类型当中</p> <pre class="prettyprint"><code>var DatabaseError = function (msg) { DatabaseError.super_.call(this, msg, this.constructor) } util.inherits(DatabaseError, AbstractError) DatabaseError.prototype.message = &#x27;Database Error&#x27; </code></pre><p>错误类型部署到应用当中，下例</p> <pre class="prettyprint"><code>function getUserById(id, callback) { if (!id) { return callback(new Error(&#x27;Id is required&#x27;)) } &#x2F;&#x2F; Let’s pretend our database breaks if we try to &#x2F;&#x2F; find a user with an id higher than 10 if (id &gt; 10) { return callback(new DatabaseError(Id can&#x27;t be higher ↵ than 10)) } callback(null, { name: &#x27;Harry Goldfarb&#x27; }) } function onGetUserById(err, resp) { if (err) { return console.log(err.toString()) } console.log(&#x27;Success:&#x27;, resp.name) } getUserById(1, onGetUserById) &#x2F;&#x2F; Harry Goldfarb getUserById(null, onGetUserById) &#x2F;&#x2F; Error: Id is required getUserById(53, onGetUserById) &#x2F;&#x2F; Database Error: Id can&#x27;t be higher than 10 </code></pre><p>效果出来了，我们的getUserById 的方法，现在可以返回两种不同类型的错误，一个是原生的错误类型，一个是自定义的数据库错误类型databaseerror，如果我们调用toString，我们可以看到错误类型的返回</p> <pre class="prettyprint"><code>&#x2F;&#x2F; start our script in production mode $ NODE_ENV=production node main.js function onGetUserById(err, resp) { if (err) { if (err instanceof DatabaseError &amp;&amp; process.env.NODE_ENV != &#x27;production&#x27;) { return console.log(err) } return console.log(&#x27;Sorry there was an error&#x27;) } console.log(resp.name) } </code></pre><p>根据不同错误类型进行不同情况的处理</p> <h2>复用错误类型</h2> <p>我们不需要每次都重新定义我们的自定义错误在每一个文件里面，我们只需要创建一个文件，调用一个很重要的node.js方法require就足够了</p> <pre class="prettyprint"><code>&#x2F;&#x2F; in ApplicationErrors.js var util = require(&#x27;util&#x27;) var AbstractError = function (msg, constr) { Error.captureStackTrace(this, constr || this) this.message = msg || &#x27;Error&#x27; } util.inherits(AbstractError, Error) AbstractError.prototype.name = &#x27;Abstract Error&#x27; var DatabaseError = function (msg) { DatabaseError.super_.call(this, msg, this.constructor) } util.inherits(DatabaseError, AbstractError) DatabaseError.prototype.name = &#x27;Database Error&#x27; module.exports = { Database: DatabaseError } &#x2F;&#x2F; in main.js var ApplicationError = require(&#x27;.&#x2F;ApplicationErrors&#x27;) function getUserById(id, callback) { if (!id) { return callback(new Error(&#x27;Id is required&#x27;)) } if (id &gt; 10) { return callback(new ApplicationError.Database(&#x27;Id cant ↵ be higher than 10&#x27;)) } callback(null, { name: &#x27;Harry Goldfarb&#x27; }) } </code></pre><p>由此可见，我们只需要定义一次，其他地方也能使用错误对象类型。</p> <p>原文：<a href="http://dustinsenos.com/articles/customErrorsInNode">Using Custom Errors in Node.js</a></p> </div>",
title: "Node.js下自定义错误类型",
last_reply_at: "2016-09-27T07:16:27.328Z",
good: true,
top: false,
reply_count: 10,
visit_count: 9191,
create_at: "2013-08-12T16:22:33.348Z",
author: {
loginname: "hexie",
avatar_url: "//gravatar.com/avatar/218220edff46df5465c8c36b0e6d1e2f?size=48"
}
},
{
id: "57de862a7d8293463a01e6c9",
author_id: "567cbe4c222744630726b2b4",
tab: "share",
content: "<div class="markdown-text"><p>需求：功能 A 需要调用第三方 API 获取数据，而第三方 API 自身是异步处理方式，在调用后会返回数据与状态 <code>{ data: &quot;查询结果&quot;, &quot;status&quot;: &quot;正在异步处理中&quot; }</code>，这样就需要间隔一段时间后再去调用第三方 API 获取数据。为了用户在使用功能 A 时不会因为第三方 API 正在异步处理中而必须等待，将用户请求加入任务队列中，返回部分数据并关闭请求。然后定时从任务队列里中取出任务调用第三方 API，若返回状态为”异步处理中“，将该任务再次加入任务队列，若返回状态为”已处理完毕“，将返回数据入库。</p> <p>根据以上问题，想到使用 Node.js + Redis sorted set 来实现任务队列。Node.js 实现自身应用 API 用来接受用户请求，合并数据库已存数据与 API 返回的部分数据返回给用户，并将任务加入到任务队列中。利用 Node.js child process 与 cron 定时从任务队列中取出任务执行。</p> <p>在设计任务队列的过程中需要考虑到的几个问题</p> <ol> <li>并行执行多个任务</li> <li>任务唯一性</li> <li>任务成功或失败后的处理</li> </ol> <p>针对以上问题的解决方案</p> <ol> <li>并行执行多个任务利用 Promise.all 来实现</li> <li>任务唯一性利用 Redis sorted set 来实现。使用时间戳作为分值可以实现将 sorted set 作为 list 来使用，在加入任务时判断任务是否已经存在，在取出任务执行时将该任务分值设置为 0，每次取出分值大于 0 的任务来执行，可以避免重复执行任务。</li> <li>执行任务成功后删除任务，执行任务失败后将任务分值更新为当前时间时间戳，这样就可以将失败的任务重新加入任务队列尾部</li> </ol> <p>示例代码</p> <pre class="prettyprint"><code>&#x2F;&#x2F; remote_api.js 模拟第三方 API &#x27;use strict&#x27;; const app = require(&#x27;express&#x27;)(); app.get(&#x27;&#x2F;&#x27;, (req, res) =&gt; { setTimeout(() =&gt; { let arr = [200, 300]; &#x2F;&#x2F; 200 代表成功，300 代表失败需要重新请求 res.status(200).send({ &#x27;status&#x27;: arr[parseInt(Math.random() * 2)] }); }, 3000); }); app.listen(&#x27;9001&#x27;, () =&gt; { console.log(&#x27;API 服务监听端口：9001&#x27;); }); </code></pre><pre class="prettyprint"><code>&#x2F;&#x2F; producer.js 自身应用 API，用来接受用户请求并将任务加入任务队列 &#x27;use strict&#x27;; const app = require(&#x27;express&#x27;)(); const redisClient = require(&#x27;redis&#x27;).createClient(); const QUEUE_NAME = &#x27;queue:example&#x27;; function addTaskToQueue(taskName, callback) { &#x2F;&#x2F; 先判断任务是否已经存在，存在：跳过，不存在：加入任务队列 redisClient.zscore(QUEUE_NAME, taskName, (error, task) =&gt; { if (error) { console.log(error); } else { if (task) { console.log(&#x27;任务已存在，不新增相同任务&#x27;); callback(null, task); } else { redisClient.zadd(QUEUE_NAME, new Date().getTime(), taskName, (error, result) =&gt; { if (error) { callback(error); } else { callback(null, result); } }); } } }); } app.get(&#x27;&#x2F;&#x27;, (req, res) =&gt; { let taskName = req.query[&#x27;task-name&#x27;]; addTaskToQueue(taskName, (error, result) =&gt; { if (error) { console.log(error); } else { res.status(200).send(&#x27;正在查询中......&#x27;); } }); }); app.listen(9002, () =&gt; { console.log(&#x27;生产者服务监听端口：9002&#x27;); }); </code></pre><pre class="prettyprint"><code>&#x2F;&#x2F; consumer.js 定时获取任务并执行 &#x27;use strict&#x27;; const redisClient = require(&#x27;redis&#x27;).createClient(); const request = require(&#x27;request&#x27;); const schedule = require(&#x27;node-schedule&#x27;); const QUEUE_NAME = &#x27;queue:expmple&#x27;; const PARALLEL_TASK_NUMBER = 2; &#x2F;&#x2F; 并行执行任务数量 function getTasksFromQueue(callback) { &#x2F;&#x2F; 获取多个任务 redisClient.zrangebyscore([QUEUE_NAME, 1, new Date().getTime(), &#x27;LIMIT&#x27;, 0, PARALLEL_TASK_NUMBER], (error, tasks) =&gt; { if (error) { callback(error); } else { &#x2F;&#x2F; 将任务分值设置为 0，表示正在处理 if (tasks.length &gt; 0) { let tmp = []; tasks.forEach((task) =&gt; { tmp.push(0); tmp.push(task); }); redisClient.zadd([QUEUE_NAME].concat(tmp), (error, result) =&gt; { if (error) { callback(error); } else { callback(null, tasks) } }); } } }); } function addFailedTaskToQueue(taskName, callback) { redisClient.zadd(QUEUE_NAME, new Date().getTime(), taskName, (error, result) =&gt; { if (error) { callback(error); } else { callback(null, result); } }); } function removeSucceedTaskFromQueue(taskName, callback) { redisClient.zrem(QUEUE_NAME, taskName, (error, result) =&gt; { if (error) { callback(error); } else { callback(null, result); } }) } function execTask(taskName) { return new Promise((resolve, reject) =&gt; { let requestOptions = { &#x27;url&#x27;: &#x27;http:&#x2F;&#x2F;127.0.0.1:9001&#x27;, &#x27;method&#x27;: &#x27;GET&#x27;, &#x27;timeout&#x27;: 5000 }; request(requestOptions, (error, response, body) =&gt; { if (error) { resolve(&#x27;failed&#x27;); console.log(error); addFailedTaskToQueue(taskName, (error) =&gt; { if (error) { console.log(error); } else { } }); } else { try { body = typeof body !== &#x27;object&#x27; ? JSON.parse(body) : body; } catch (error) { resolve(&#x27;failed&#x27;); console.log(error); addFailedTaskToQueue(taskName, (error, result) =&gt; { if (error) { console.log(error); } else { } }); return; } if (body.status !== 200) { resolve(&#x27;failed&#x27;); addFailedTaskToQueue(taskName, (error, result) =&gt; { if (error) { console.log(error); } else { } }); } else { resolve(&#x27;succeed&#x27;); removeSucceedTaskFromQueue(taskName, (error, result) =&gt; { if (error) { console.log(error); } else { } }); } } }); }); } &#x2F;&#x2F; 定时，每隔 5 秒获取新的任务来执行 let job = schedule.scheduleJob(&#x27;*&#x2F;5 * * * * *&#x27;, () =&gt; { console.log(&#x27;获取新任务&#x27;); getTasksFromQueue((error, tasks) =&gt; { if (error) { console.log(error); } else { if (tasks.length &gt; 0) { console.log(tasks); Promise.all(tasks.map(execTask)) .then((results) =&gt; { console.log(results); }) .catch((error) =&gt; { console.log(error); }); } } }); }); </code></pre></div>",
title: "Node.js + Redis Sorted Set 任务队列",
last_reply_at: "2016-09-27T06:56:53.709Z",
good: false,
top: false,
reply_count: 3,
visit_count: 1612,
create_at: "2016-09-18T12:18:50.085Z",
author: {
loginname: "DuanPengfei",
avatar_url: "https://avatars.githubusercontent.com/u/4469502?v=3&s=120"
}
},
{
id: "57ea0aa73670ca3f44c5bea4",
author_id: "54d1a446753ddc9128ad8bad",
tab: "ask",
content: "<div class="markdown-text"><p>同样的减法运算可以处理，用加法运算就当做了字符串操作 代码如下： a href=&quot;/product/QueryList?curentPage=&lt;%=currentPage-1%&gt;&quot;&gt; <a href="//xn--ciq440b03firfb6pu09a">//这个是正常的</a> a href=&quot;/product/QueryList?curentPage=&lt;%=currentPage+1%&gt;&quot;&gt; //这里比如currentPage是1，那么结果就是11，为什么加法就当做字符串处理了呢？如何能正确运行加法运算？</p> </div>",
title: "我在EJS模板页面使用加法运算符，为什么给我当成字符串处理了？",
last_reply_at: "2016-09-27T06:22:17.998Z",
good: false,
top: false,
reply_count: 4,
visit_count: 81,
create_at: "2016-09-27T05:59:03.550Z",
author: {
loginname: "bendise",
avatar_url: "https://avatars.githubusercontent.com/u/6418989?v=3&s=120"
}
},
{
id: "57e65f5fc82da6fd04be794b",
author_id: "57df88ff7d8293463a01e70b",
tab: "share",
content: "<div class="markdown-text"><pre class="prettyprint language-js"><code>&#x2F;* Promise到底是个什么梗？ 作为新手，这两天被promise弄得对Node.js的兴趣少了一半！百度&#x27;nodejs promise&#x27;出来的文章基本都是你抄我我抄你，没有一个能讲明白的，难道用一些通俗易懂的例子来解释就这么难吗?，我没学过es6，只会一些非常简单的js语法，我只想用node做点小玩意，难道不学es6就玩不了node吗？劳资偏不信这个邪！ *&#x2F; var Promise = require(&#x27;bluebird&#x27;); var util = require(&#x27;util&#x27;); &#x2F;*一个简单得不能再简单的模拟的异步方法*&#x2F; function sum(p1, p2, callback){ setTimeout(function(){ var e = parseInt(Math.random()*10);&#x2F;&#x2F;模拟随机产生异常 if(e){ callback(null, p1+p2); }else{ callback(util.format(&quot;发生异常:p1=%d, p2=%d&quot;,p1,p2)); } },1000); } &#x2F;&#x2F;一般异步方法都是这样用的：（像fs、http等） &#x2F;* sum(1, 2, function (err, sum) { if(err){ console.log(err); } else { console.log(sum); } }) *&#x2F; &#x2F;* &#x2F;&#x2F;而一些情况下我们真的会这样用： sum(1, 2, function (err, sum) { if(err){ console.log(err); } else { sum(sum, 3, function (err, sum) { if(err){ console.log(err); } else { sum(sum, 4, function (err, sum) { if(err){ console.log(err); } else { console.log(sum); } }); } }); } }) *&#x2F; &#x2F;* 整个逻辑简单得不得了,而代码却像屎一样难看，但是下一步的操作总是依赖上一步的操作，虽然方法是异步的，但是你只能这样嵌套，你有更好的办法吗？请告诉我 这个逻辑就像是： 1.一个用户请求访问一个文件，但是我首先要判断一下文件是否存在，这就是第一个异步了 2.如果文件存在，我又去数据里查一下这个文件他能不能访问，这又是一个异步 3.如果可以访问，最后我再把这个文件发送出去，这又是一个异步 你说这种逻辑不是和php之类的一样吗？node的异步方式有个卵用！ 是的，我也是这么认为的，但是“大家好才是真的好”，大家都说好，那必有其道理，是我等还没领悟到。那没领悟到之前，问题总得解决吧， 这种屎一样的代码除了电脑，谁看了都不爽. 先不说传说中的Promise库怎么用，想想connect或express对中间件的处理方式 app.use(中间件1) app.use(中间件2) app.use(中间件3) app.use(异常处理中间件) 中间件怎么处理的呢？当前中间件处理不了或者完成了工作就转移到下一个中间件 function(req,res,next){ &#x2F;&#x2F;一般中间件大概长这个样子，和http.createServer()那个回调不同的是，多了一个next参数 next(); &#x2F;&#x2F;next是个函数，调用他之后就会把工作转移到下一个中间件，next可以传递参数，这参数一传就直接跳到异常处理去了！不传就是到下一个普通中间件 } 异常处理中间件 function(err,req,res,next){ &#x2F;&#x2F;区别就是第一个参数是err，这种区别怎么判断呢? arguments.length判断函数的参数个数！！！就这么简单 next(&#x27;error&#x27;); &#x2F;&#x2F;和普通中间件一样，这里给下一个异常处理传了&#x27;error&#x27;字符串，就是第一个参数，普通中间件的next玩法一样 } 对于中间件我大概就说这么多了。基于这种思想，寡人自己发明了个轮子： *&#x2F; &#x2F;* function Next(){ this.funcs = []; } Next.prototype.next = function(callback){ this.funcs.push(callback); return this; } Next.prototype.start = function(){ var func = this.funcs.shift(); func &amp;&amp; func.apply(this,arguments); } exports = module.exports = Next; &#x2F;&#x2F;用法很简单,next()就是不断的添加函数，start就是按顺序执行他们， var next = new Next(); next.next(function(p1,p2){ sum(p1,p2,function(e,sum){ if(e){ console.log(e); }else{ next.start(sum,3); } }) }).next(function(p1,p2){ sum(p1,p2,function(e,sum){ if(e){ console.log(e); }else{ next.start(sum,4); } }) }).next(function(p1,p2){ sum(p1,p2,function(e,sum){ if(e){ console.log(e); }else{ console.log(sum); } }) }) next.start(1,2) *&#x2F; &#x2F;* 程序还是那个程序，但是层次结构清晰多了，毕竟node.js也有些年头了，我等菜鸟没有必要重新发明轮子 var Promise = require(&#x27;bluebird&#x27;); &#x2F;&#x2F;bluebird就是一个现成的Promise，拿过来用 Promise据说就能解决坑爹的回调问题，但是，寡人却看不懂网上别人写的文章到底TM是什么意思！ Promise大概说的是这样一种结构： Promise(function(){ &#x2F;&#x2F;异步操作1 }).then(function(data){ &#x2F;&#x2F;异步操作2，可以收到上面那个异步操作的结果 }).then(function(data){ &#x2F;&#x2F;异步操作3，可以收到上面那个异步操作的结果 }).catch(function(e){ &#x2F;&#x2F;如果上面的任何一步发生异常就直接到这里了 }) *&#x2F; &#x2F;&#x2F;这就是一个基本的用法 &#x2F;* new Promise(function(resolve, reject){ &#x2F;&#x2F;原理和我的轮子差不多，不过调用下一步的方法放到了函数参数上，我不清楚这有什么好处 sum(1, 2, function(err, sum){ if (err) { reject(err); } else { resolve(sum) } }); }).then(function(data){ console.log(data); }).catch(function(err){ console.log(err); }); *&#x2F; &#x2F;&#x2F;问题就TM来了，是啊，这是把回调拆开来了，可是then里面没有resolve, reject了，下一步呢？ &#x2F;* new Promise(function(resolve, reject){ sum(1, 2, function(err, sum){ if (err) { reject(err); } else { resolve(sum) } }); }).then(function(data){ console.log(data); }).then(function(data){ &#x2F;&#x2F;我先不管下一步怎么办，上面不是说是.then().then()这种结构嘛，我毫不犹豫地就复制了一份 console.log(data); &#x2F;&#x2F;输出undefined，尼码，还真执行了，但是上一步没有resolve来传递参数啊！ }).catch(function(err){ console.log(err); }); *&#x2F; &#x2F;&#x2F;经过研究，原来是要在then()里再返回一个Promise对象 &#x2F;* new Promise(function(resolve, reject){ sum(1, 2, function(err, sum){ if (err) { reject(err); } else { resolve(sum) } }); }).then(function(data){ console.log(data); return new Promise(function(resolve, reject){ &#x2F;&#x2F;屎一样的代码，原来是要这么用！ sum(data, 3, function(err, sum){ if (err) { reject(err); } else { resolve(sum) } }); }) }).then(function(data){ console.log(data); }).catch(function(err){ &#x2F;&#x2F;原来catch真的可以在上面任何一个地方出错时中断顺序直接到达这里，这真的不好理解，按理来说别的Promise对象发生什么事不归他管啊？ console.log(err); }); *&#x2F; &#x2F;*现在，让我们的代码变得更加优雅一点吧 &#x2F;&#x2F;对sum函数进行包装 function psum(p1,p2){ return new Promise(function(resolve,reject){ sum(p1, p2, function(err,s){ if(err){ reject(err); }else{ resolve(s); } }); }); } psum(1,2).then(function(data){ console.log(data); return psum(data,3); }).then(function(data){ console.log(data); return psum(data,4); }).then(function(data){ console.log(data); &#x2F;&#x2F;return ; &#x2F;&#x2F;达到最终目的，没有必要再返回什么东西了 }).catch(function(err){ console.log(err); }); &#x2F;&#x2F;当然bluebird给我们提供了更简单的方式帮我们自动完成了，你可以试试用下面这行代码来代替我们手动包装的psum &#x2F;&#x2F;var psum = Promise.promisify(sum); *&#x2F; </code></pre><h3><strong>以上这就是Promise的一个基本用法了。</strong></h3> <pre class="prettyprint language-js"><code>&#x2F;* &#x2F;&#x2F;然而，事情并不是我们想像中那么美好，定义一个ret函数，只是简单的把两个参数原封不动返回 function ret(p1, p2, callback){ setTimeout(function(){ var e = parseInt(Math.random()*10);&#x2F;&#x2F;模拟随机产生异常 if(e){ callback(null, p1, p2); }else{ callback(util.format(&quot;发生异常:p1=%d, p2=%d&quot;,p1,p2)); } },1000); } &#x2F;&#x2F;var pret = Promise.promisify(ret); var pret = function(p1,p2){ return new Promise(function(resolve,reject){ ret(p1,p2,function(e, a, b){ if(e){ reject(e); }else{ resolve(a,b); } }); }); }; pret(11,22).then(function(a,b){ &#x2F;&#x2F;我想当然的以为a,b会传回来，然而并没有，这就是说resolve只能传递一个参数 console.log(a,b); &#x2F;&#x2F;11 undefined console.log(arguments); &#x2F;&#x2F;{ &#x27;0&#x27;: 11 } }).catch(function(e){ console.log(e); }); *&#x2F; &#x2F;* Promise还有一个网上传说中的用法 **无关系汇总任务** *&#x2F; function foo(p1, p2, callback){&#x2F;&#x2F;还是一个异步的加法 var str = &#x27;foo(&#x27;+p1+&#x27;,&#x27;+p2+&#x27;)&#x27;; var delay = (p1==1) ? 3000 : 1000;&#x2F;&#x2F;故意让pfoo(1,2)返回得慢一些 console.log(str + &#x27;异步开始&#x27;); setTimeout(function(){ console.log(str + &#x27;异步完成&#x27;); callback(null, p1+p2); },delay); } var pfoo = Promise.promisify(foo);&#x2F;&#x2F;Promise化foo函数 var promise1 = pfoo(1,2); var promise2 = pfoo(3,4); var arr = [ promise1, promise2 ]; Promise.all(arr).then(function(datas){ console.log(datas); var sum = 0; for(var i in datas){ sum += datas[i]; } console.log(&#x27;sum=&#x27; + sum); }); &#x2F;* 结果： foo(1,2)异步开始 foo(3,4)异步开始 foo(3,4)异步完成 foo(1,2)异步完成 [ 3, 7 ] sum=10 可以看到两次调用是‘同时执行’的，而不是一个等待另一个执行完毕再执行 这样一来上面所说的： “1.一个用户请求访问一个文件，但是我首先要判断一下文件是否存在，这就是第一个异步了 2.如果文件存在，我又去数据里查一下这个文件他能不能访问，这又是一个异步 3.如果可以访问，最后我再把这个文件发送出去，这又是一个异步” 就可以优化了： 同时两个异步任务，一个检查文件是否存在，另一个去查数据库 两个任务都完成了再根据两个任务的结果决定最终的处理方式，这样，node异步方式的优势似乎又回来了。 以上内容均属个人观点，如有雷同纯属巧合，如有异议者请详细说明，寡人读书少，网上的Promise真的太概念化了，对新手一点都不友好 2016&#x2F;09&#x2F;04 19:05 入node坑一星期左右，之前几乎没用js做过什么事情 *&#x2F; </code></pre></div>",
title: "Promise到底是个什么梗？--node超级大菜鸟的革命之路",
last_reply_at: "2016-09-27T05:31:56.689Z",
good: false,
top: false,
reply_count: 6,
visit_count: 445,
create_at: "2016-09-24T11:11:27.427Z",
author: {
loginname: "zengming00",
avatar_url: "https://avatars.githubusercontent.com/u/5255081?v=3&s=120"
}
},
{
id: "57df8ff07d8293463a01e70f",
author_id: "57df84493af3942a3aa3b881",
tab: "job",
content: "<div class="markdown-text"><p>我们的产品通过<strong>数据技术</strong>帮助用户更高效租到好房子，免受虚假信息骚扰，省时省钱，让租房子变成一件轻松的事。目前正在做上线前的完善开发，会跟你见过的找房子服务都不一样。我们做的是技术和机器驱动的事情，会很有意思。</p> <p>创始团队班底源自 Opera ，世界少数几家专业浏览器厂商。成员是做浏览器和分布式计算的产品技术牛人，有足够的驾驭复杂技术产品的能力。我们曾为中国用户从 10 万到千万级的增长做了绵薄贡献，但没达到十年前自己定下的亿级小目标，所以我们重新上路折腾。</p> <p>已经拿到充足初期投资，天使投资人本身是位非常厉害的创业者，除了给我们宝贵的经验，还将帮助我们引入顶级机构的投资——前提当然是我们做出有价值的产品。</p> <h3>🙉 需求</h3> <ul> <li>技术涉及的几方面（按对你的重要程度排列）：系统架构（ Node.js 等）、数据挖掘 / 模式识别 / 机器学习、搜索技术。最希望你是这几方面都搞得定的全栈工程师，但如果能在某一两方面特别擅长，我们也热烈欢迎！</li> <li>有面向最终用户产品的研发经验，且希望你曾从产品的初创阶段就参与创作。</li> <li>能建团队能带人（带人的意思不是所谓管人，而是帮助团队成员变得更好）。</li> <li>能扛事儿。</li> <li>必须要有好奇心和创造精神，愿意挑战和折腾。</li> <li>加分项：用 Emacs ；严重减分项：只用过 Windows 。</li> </ul> <p>浏览器研发的基因让我们深知 Web 技术作为基础技术的威力，这些杀器也在走出浏览器本身，以新的形态渗透到不同技术领域（比如 Node.js、React Native、Electron 等）。我们对这些新形态有强烈兴趣，这也是选择衍生自浏览器的 Node.js 作为主技术的重要原因。</p> <p>但我们不硬性要求成员一定要有 Node.js 的开发经验，用动态语言做过靠谱的服务器程序就足够了（Python / Ruby / PHP，甚至 Go / Pike / LISP 等）——当然如果你还接受过 C / C++ 的洗礼那就更棒了！</p> <h3>💰 给予</h3> <ul> <li>有竞争力的薪资，大量早期股票期权，绝对的诚意。</li> <li>关乎团队效率和爽感的投入绝不吝啬，MacBook Pro、正版开发工具、内部工具等等，反正机器能干的事就一定让机器干。</li> <li>考虑请位阿姨做饭，让大家吃得安心。</li> <li>Open 和透明的工作方式。</li> <li>最紧要开心！想尝试不同的工作挑战自己？想吐槽 CEO？都没问题！随时倾听你的任何意见，全力支持你的个人发展。创业本来就应该是实现团队成员梦想的同时，顺便把公司的梦想实现了。</li> </ul> <p>我们不只是技术 geek，还喜欢从用户的角度思考价值和体验，我相信产品就是我们的作品。来一起折腾，拼尽全力做点能让自己骄傲的事情，一定会很好玩～</p> <hr> <p>👬👫👬👬👫👬</p> <p><strong>我们以前 hack 产品、技术和设计，现在希望把技术应用到基础生活，尝试 hack 一下社会的运作方式，来一起折腾吧🖖🏼</strong></p> <p>有兴趣直接联系创始人冯嘉彬（本人），</p> <ul> <li>微信 jiabinf ，或识别下方二维码，请说明来自 CNode。</li> <li>邮箱 <a href="http://xn--benplusplusgmail-gg6mp7342a.com">benplusplus⭕️gmail.com</a></li> </ul> <hr> <p>PS ：目前的技术栈： Node.js / MongoDB / Jieba / PM2 / R 语言 / Responsive Web UI / Bootstrap / Github / Slack / Gulp / Mocha / ESLint</p> <p>PPS ：如果你喜欢喵就更好，我们可以在办公室养一只（咦这话好基～）。</p> <p><img src="http://ww1.sinaimg.cn/large/7007bc19gw1f7xvtaszl1j20m80ectak.jpg" alt="微信二维码"></p> </div>",
title: "[广州] 技术初创团队寻 Node.js 全栈，数据挖掘及搜索系统🤖️🚀来折腾点有挑战的事",
last_reply_at: "2016-09-27T05:31:47.201Z",
good: false,
top: false,
reply_count: 3,
visit_count: 173,
create_at: "2016-09-19T07:12:48.273Z",
author: {
loginname: "jiabinf",
avatar_url: "https://avatars.githubusercontent.com/u/5972237?v=3&s=120"
}
},
{
id: "57c529cf9b447b634391c814",
author_id: "54009f5ccd66f2eb37190485",
tab: "share",
content: "<div class="markdown-text"><h1>使用node-crawler和jsdom完成爬虫</h1> <h2>初衷</h2> <p>从天蚕土豆的《大主宰》Huge Dominate</p> <p>起点上是付费的，不经常看，偶尔看看而已，付费没啥意思。于是找免费的</p> <p><a href="http://www.biquku.com/0/330/">http://www.biquku.com/0/330/</a></p> <p>即使说无弹窗，可是还是有很多广告。。。</p> <p>作为一个有追求的程序员能忍么？</p> <h2>node-crawler说明</h2> <p>爬取《大主宰》的所有章节列表</p> <p><img src="https://github.com/i5ting/simplereader/raw/master/docs/images/1.png" alt="1"></p> <pre class="prettyprint"><code>var Crawler = require(&quot;crawler&quot;); var jsdom = require(&#x27;jsdom&#x27;); var c = new Crawler({ jQuery: jsdom, maxConnections : 100, forceUTF8:true, &#x2F;&#x2F; incomingEncoding: &#x27;gb2312&#x27;, &#x2F;&#x2F; This will be called for each crawled page callback : function (error, result, $) { var urls = $(&#x27;#list a&#x27;); console.log(urls) } }); c.queue(&#x27;http:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;&#x27;); </code></pre><p>执行</p> <pre class="prettyprint"><code>node examples&#x2F;1&#x2F;hello-crawler.js </code></pre><h2>解析章节信息</h2> <p>代码</p> <pre class="prettyprint"><code>var Crawler = require(&quot;crawler&quot;); var jsdom = require(&#x27;jsdom&#x27;); var current_book = { } var c = new Crawler({ jQuery: jsdom, maxConnections : 100, forceUTF8:true, &#x2F;&#x2F; incomingEncoding: &#x27;gb2312&#x27;, &#x2F;&#x2F; This will be called for each crawled page callback : function (error, result, $) { var urls = $(&#x27;#list a&#x27;); &#x2F;&#x2F; console.log(urls) current_book.title = $(&#x27;#maininfo h1&#x27;).text() current_book.author = $(&#x27;#info p&#x27;).eq(0).text() current_book.update_time = $(&#x27;#info p&#x27;).eq(2).text() current_book.latest_chapter = $(&#x27;#info p&#x27;).eq(3).html() current_book.intro = $(&#x27;#intro&#x27;).html() current_book.chapters = []; for(var i = 0; i&lt; urls.length; i++){ var url = urls[i] var _url = $(url).attr(&#x27;href&#x27;)+&quot;&quot;; var num = _url.replace(&#x27;.html&#x27;,&#x27;&#x27;); var title = $(url).text(); current_book.chapters.push({ num: num, title: title, url: _url }) } console.log(current_book) } }); c.queue(&#x27;http:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;&#x27;); </code></pre><p>这里主要是拿jQuery解析dom。然后赋值current_book</p> <p>执行</p> <pre class="prettyprint"><code>node examples&#x2F;1&#x2F;chaper-list.js { title: &#x27;大主宰&#x27;, author: &#x27;作    者：天蚕土豆&#x27;, update_time: &#x27;更新时间：2016-07-10&#x27;, latest_chapter: &#x27;最新章节：&lt;a href=&quot;4091426.html&quot; target=&quot;_blank&quot;&gt;第一千两百六十二章 大陆洗礼&lt;&#x2F;a&gt;&#x27;, intro: &#x27;\n\t\t\t\t\t&lt;p&gt; 大千世界，位面交汇，万族林立，群雄荟萃，一位位来自下位面的天之至尊，在这无尽世界，演绎着令人向往的传奇，追求着那主宰之路。\n 无尽火域，炎帝执掌，万火焚苍穹。\n 武境之内，武祖之威，震慑乾坤。\n 西天之殿，百战之皇，战威无可敌。\n 北荒之丘，万墓之地，不死之主镇天地。\n ......\n 少年自北灵境而出，骑九幽冥雀，闯向了那精彩绝伦的纷纭世界，主宰之路，谁主沉浮？\n 大千世界，万道争锋，吾为大主宰。\n ..................\n&lt;&#x2F;p&gt;\n\t\t\t\t\t&lt;p&gt;各位书友要是觉得《大主宰》还不错的话请不要忘记向您QQ群和微博里的朋友推荐哦！&lt;&#x2F;p&gt;\n\t\t\t\t&#x27;, chapters: [ { num: &#x27;153064&#x27;, title: &#x27;第一章已发。&#x27;, url: &#x27;153064.html&#x27; }, { num: &#x27;153065&#x27;, title: &#x27;第一章 北灵院&#x27;, url: &#x27;153065.html&#x27; }, { num: &#x27;153066&#x27;, title: &#x27;第二章 被踢出灵路的少年&#x27;, url: &#x27;153066.html&#x27; }, { num: &#x27;153067&#x27;, title: &#x27;第三章 牧域&#x27;, url: &#x27;153067.html&#x27; }, { num: &#x27;153068&#x27;, title: &#x27;第四章 大浮屠诀&#x27;, url: &#x27;153068.html&#x27; }, </code></pre><p>想要的信息都准备好了，下面就开始爬某一章吧</p> <h2>爬取某一章</h2> <p>看一下</p> <pre class="prettyprint"><code>第一章 北灵院 http:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;153065.html </code></pre><p>和之前的地址的差别是什么呢？</p> <ul> <li><a href="http://www.biquku.com/0/330">http://www.biquku.com/0/330</a> 是一样的</li> <li>153065.html章节地址</li> </ul> <p>再回顾一下</p> <pre class="prettyprint"><code> chapters: [ { num: &#x27;153064&#x27;, title: &#x27;第一章已发。&#x27;, url: &#x27;153064.html&#x27; }, </code></pre><p>也就是说 url 即是章节地址，剩下的就拼接起来就好了。</p> <pre class="prettyprint"><code>function one(chapter){ console.log(chapter) c.queue([{ uri: &#x27;http:&#x2F;&#x2F;www.biquku.com&#x2F;0&#x2F;330&#x2F;&#x27; + chapter.num + &#x27;.html&#x27;, jQuery: jsdom, forceUTF8:true, &#x2F;&#x2F; The global callback won&#x27;t be called callback: function (error, result, $) { var content = $(&#x27;#content&#x27;).html(); console.log(content) } }]); } </code></pre><p>模拟执行代码</p> <pre class="prettyprint"><code>var chapter = { num: &#x27;4063307&#x27;, title: &#x27;第一千两百五十二章 现世！&#x27;, url: &#x27;4063307.html&#x27; } one(chapter); </code></pre><p>执行</p> <pre class="prettyprint"><code>node examples&#x2F;1&#x2F;chaper-one.js { num: &#x27;4063307&#x27;, title: &#x27;第一千两百五十二章 现世！&#x27;, url: &#x27;4063307.html&#x27; } &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一千两百五十二章&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;轰轰！&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;灵战子的低吼声，犹如雷鸣一般在这天地之间回荡，一股股磅礴浩瀚的灵力，也是犹如洪流一般，不断的从其体内呼啸而出，引得空间震荡。◇↓，&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此时的灵战子，双目精光涌动，神采飞扬，再没了先前的那种虚弱之感，显然，借助着那所谓的“战祭”，他直接是在顷刻间就将自身状态恢复到了巅峰。&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前消耗的灵力，也是再度充盈了他的身躯。 </code></pre><h2>总结</h2> <p>爬取一本书的流程</p> <ul> <li>先取列表</li> <li>再去章节</li> </ul> <p>技能</p> <ul> <li>node-crawler 爬取，发送http请求，是基于request模块的</li> <li>结合jsdom，使用类似于jquery的dom操作，解析结果</li> </ul> <p>node-crawler有2种用法</p> <ul> <li>c.queue方法如无callback，走全局的callback，这是获取列表的时候的用法</li> <li>c.queue方法如有callback，走自己的callback，这是获取章节的用法</li> </ul> <p>我们的做法</p> <ul> <li>最小化问题，先关注爬取一本书的流程</li> <li>爬取一本书的流程中的列表</li> <li>爬取一本书的流程中的章节</li> </ul> <p>在这个过程中，我们可以很好的学习node-crawler和jquery的dom操作，知识点整体来说比较少，更加容易学习。</p> <p>下面，爬取的信息咋办呢？见下一章。</p> <h2>更多</h2> <p>参见 <a href="https://github.com/i5ting/githubrank">https://github.com/i5ting/githubrank</a></p> <p>全文完</p> <p>欢迎关注我的公众号【node全栈】</p> <p><img src="//dn-cnode.qbox.me/FtALxsauUkYDGdzcuA5y6BaIdUMC" alt="node全栈.png"></p> </div>",
title: "Node.js写爬虫系列",
last_reply_at: "2016-09-27T05:30:19.121Z",
good: true,
top: false,
reply_count: 43,
visit_count: 4063,
create_at: "2016-08-30T06:38:07.475Z",
author: {
loginname: "i5ting",
avatar_url: "https://avatars.githubusercontent.com/u/3118295?v=3&s=120"
}
},
{
id: "57e951810424cced19b35cae",
author_id: "548ce63d57fd3ae46b233473",
tab: "ask",
content: "<div class="markdown-text"><p><strong>来自江苏扬州的一名Coder</strong></p> <p>很宅，除了之前的同事，朋友圈很小，也很难有机会认识更多；实在孤独，想认识更多来自这里的Coder。</p> <hr> <p><strong>想让自己的家乡是个Coder梦寐的地方</strong></p> <p>想这里能诞生更多优秀的团队，产品，公司；想这里的公司能更重视技术人员；想这里的技术人员有更好的资源和环境；想这里是更多Coder渴求的地方！ 入行7年，在二线城市磨练过，回来扬州组建了团队，做过一些小有成就的事情，目前没有固定工作，有一个合伙人，想把扬州的开发者的氛围活跃起来，让这个三线小城市的开发者能有更多的机会相互学习，相互促进。 有家有室，想去北上广见见世面、燃烧青春，可总没有归属感，也总想提到自己的家乡是个Coder梦寐的地方，相信有不少和我有类似想法的人，你们在哪里？</p> <hr> <p><strong>这是一片荒芜</strong></p> <p>这里没有举办过任何关于开源分享的聚会，没有关于成长的分享，没有相互竞争，没有相互帮助；有的只是一片荒芜，一些公司还不知道git是什么，还没有能力使用linux服务器，没听过测试驱动开发、angularjs、vuejs ； 开源中国也没有扬州站；在｀烟花三月下扬州｀这么好风水的地方，这点开源的风都刮不起来么？</p> <hr> <p><strong>请来自江苏扬州的你站出来，我们等你很久了</strong></p> <p>最后留下我的微信：yfsoftcom QQ: 1794947912</p> </div>",
title: "像我一样来自江苏扬州的开源爱好者有多少？",
last_reply_at: "2016-09-27T04:27:23.740Z",
good: false,
top: false,
reply_count: 5,
visit_count: 135,
create_at: "2016-09-26T16:49:05.385Z",
author: {
loginname: "yfsoftcom",
avatar_url: "https://avatars.githubusercontent.com/u/3324813?v=3&s=120"
}
},
{
id: "57e93967bb55ef3e1a17fcc3",
author_id: "57deb3cb7d8293463a01e6d1",
tab: "ask",
content: "<div class="markdown-text"><p>Node的异步思想容易理解，实际运用很难啊，请大神推荐一些资料，以供阅读</p> </div>",
title: "Node的异步思想容易理解，实际运用很难啊，请大神推荐一些资料，以供阅读",
last_reply_at: "2016-09-27T04:25:36.547Z",
good: false,
top: false,
reply_count: 3,
visit_count: 175,
create_at: "2016-09-26T15:06:15.444Z",
author: {
loginname: "muyoucun557",
avatar_url: "https://avatars.githubusercontent.com/u/22274829?v=3&s=120"
}
},
{
id: "57e917e2bb55ef3e1a17fcbd",
author_id: "504c28a2e2b845157708cb61",
tab: "share",
content: "<div class="markdown-text"><p>https 已经是目前有逼格网站的标配。https 在现在也不像之前一样高价或难以配置。 以下介绍几种常见的 https 证书获取方式，并说说 https 证书颁发验证过程中几个有趣的点。</p> <hr> <p>1, 通过 let’s encrypt</p> <p>它由 ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。</p> <p>申请 Let’s Encrypt 证书不但免费，还非常简单，虽然每次只有 90 天的有效期，但可以通过脚本定期更新，配好之后一劳永逸。</p> <p>相关的配置过程可以参考：<a href="https://imququ.com/post/letsencrypt-certificate.html">https://imququ.com/post/letsencrypt-certificate.html</a></p> <p>2, 腾讯云免费 ssl 证书申请</p> <p><a href="https://console.qcloud.com/ssl">https://console.qcloud.com/ssl</a></p> <p>这个证书申请就跟常规的证书申请流程类似了。只是我个人是腾讯云的，熟悉这个产品，觉得流程很清晰，就推荐出来</p> <p>3, CDN 服务商一键提供</p> <p>据说 cloudflare 目前是接入了之后就自动获得 https 的特性，这个我同事说他确认了。</p> <p>而在国内的来说的话，接入腾讯云 CDN 之后，也可以一键开启。毕竟用户访问网站的节点都是 CDN 提供的，CDN 只要在自己的服务器上配置好证书即可让用户一键开启。</p> <hr> <p>证书校验的几种方式：</p> <p>1, 邮箱验证</p> <p>邮件校验就是，比如我有 <a href="http://cnodejs.org">cnodejs.org</a> 这个域名，证书颁发商就发个邮件到 <a href="mailto:admin@cnodejs.org">admin@cnodejs.org</a> ，如果我能成功接收这个邮件，则说明我具有域名的控制权，可以被颁发证书。</p> <p>2, 文件校验</p> <p>这个校验方式也挺常见的。证书颁发商给你一个 5d41402abc4b2a76b9719d911017c592.html ，让你放到 <a href="http://cnodejs.org/5d41402abc4b2a76b9719d911017c592.html">http://cnodejs.org/5d41402abc4b2a76b9719d911017c592.html</a> 下，如果你能放置成功，则也可以颁发。</p> <p>3, dns 校验</p> <p>这个是说，证书商会让你把类似 <a href="http://5d41402abc4b2a76b9719d911017c592.cnodejs.org">5d41402abc4b2a76b9719d911017c592.cnodejs.org</a> 的域名 cname 到某个地址。如果你能成功操作，则也说明你有域名的控制权。</p> <hr> <p>回顾上述的获取方式那里，lets encrypt 用的是文件校验；腾讯云申请证书的话，貌似邮箱和dns校验都有；cdn 这边用的是文件校验。</p> <p>之所以 cdn 这边可以一键开启，是因为 cdn 服务提供商具备权限，可以劫持你接入的域名的文件访问。当开启 https 功能时，cdn提供商通过 api 与证书颁发商进行沟通，自动化完成了文件校验的过程并获取证书。</p> <p>上述三种校验方式里面，我个人认为第三种是最方便也最安全的。</p> <p>邮箱验证这个，其实颁发商不一定会发邮件到 admin 里面去，我印象中可以选择什么 webmaster，sitemaster 等等一大堆域名前缀。</p> <p>如果你的域名可以被用户开放申请的话，这就显得很不安全。</p> <p>文件校验这个，可以看看这篇文章。<a href="http://weibo.com/ttarticle/p/show?id=2309614015410096792473">《尴尬！国内CA机构沃通错误颁发GitHub域名SSL证书 》</a>，简而言之，就是有人通过操作 <a href="http://your-username.github.com">your-username.github.com</a> 的域名，获取了 <a href="http://github.com">github.com</a> 的根证书。用过 github pages 的朋友应该知道我在说什么。</p> <p>上述申请方式里面，lets encrypt 的配置其实还是比较麻烦，而去腾讯云一次只有一年，每年需要记得更新。cdn服务商那种，就看你用不用cdn了。</p> <p>就目前 <a href="https://cnodejs.org/">https://cnodejs.org/</a> 的情况来说，主站这边我用的是 lets encrypt，配置了自动更新证书，所以证书永不过期。静态文件方面，用的是七牛提供的 ssl 域名，所以 ssl 证书不用我操心。</p> </div>",
title: "https 免费证书获取指引",
last_reply_at: "2016-09-27T03:50:43.343Z",
good: false,
top: false,
reply_count: 3,
visit_count: 217,
create_at: "2016-09-26T12:43:14.808Z",
author: {
loginname: "alsotang",
avatar_url: "https://avatars.githubusercontent.com/u/1147375?v=3&s=120"
}
},
{
id: "57e9d84356898f231a526f96",
author_id: "5531d85e1b9662da568db86f",
tab: "ask",
content: "<div class="markdown-text"><p>今天在看<a href="https://github.com/vuejs/vue-hackernews">vue-hackernews</a>的源代码,发现这样一段代码：</p> <pre class="prettyprint language-js"><code>export function fromNow (time) { const between = Date.now() &#x2F; 1000 - Number(time) if (between &lt; 3600) { return pluralize(~~(between &#x2F; 60), &#x27; minute&#x27;) } else if (between &lt; 86400) { return pluralize(~~(between &#x2F; 3600), &#x27; hour&#x27;) } else { return pluralize(~~(between &#x2F; 86400), &#x27; day&#x27;) } } function pluralize(time, label) { if (time === 1) { return time + label } return time + label + &#x27;s&#x27;; } </code></pre><p>其中<code>~~(between / 60)</code>,不明白为什么要这样写？</p> <p>对任一数值 x 进行按位非操作的结果为 -(x + 1)，那<code>~~x</code>的结果是<code>-(-(x+1)+1)</code>，结果还是x，那为什么还要在前面加上<code>~~</code>呢？</p> </div>",
title: "关于按位非操作符（~）的问题？",
last_reply_at: "2016-09-27T03:44:52.107Z",
good: false,
top: false,
reply_count: 4,
visit_count: 91,
create_at: "2016-09-27T02:24:03.626Z",
author: {
loginname: "QuoniamYIF",
avatar_url: "https://avatars.githubusercontent.com/u/12003094?v=3&s=120"
}
},
{
id: "57e9c64156898f231a526f90",
author_id: "54009f5ccd66f2eb37190485",
tab: "share",
content: "<div class="markdown-text"><h1>微信应用号官方IDE破解助手</h1> <p>helper for <a href="https://github.com/gavinkwoe/weapp-ide-crack">https://github.com/gavinkwoe/weapp-ide-crack</a></p> <p>第一批内测只有200个，所以大部分人都没办法弄到，但又想提前体验，怎么办呢？</p> <p>先从 <a href="https://github.com/gavinkwoe/weapp-ide-crack">https://github.com/gavinkwoe/weapp-ide-crack</a> 开始说起吧。</p> <h2>gavinkwoe是谁？</h2> <p>gavinkwoe是郭虹宇，老郭以前在腾讯，后来出来在呼家楼那边创业，很棒的公司，他本人技术也是相当到位的，最早是beeframework，代码写的还是相当棒，这货对tcp和c也相当厉害，据说拿过专利。后来bee半火不火的，就搞了类似于css描述生成iOS页面的东西，之后react-native出来之后，貌似就转rn了。而且还带出了QFish这样的优秀小弟，很棒的。</p> <p>总之，老郭有非常强大的iOS开发能力，所以这次破解微信开发工具也是有一定必然性的。</p> <h2>小助手：weide</h2> <p><a href="https://github.com/i5ting/weide">https://github.com/i5ting/weide</a></p> <p>它其实就为了简化安装破解而写的简单小程序。利用node模块和npm强大的机制，简化破解并提供实用辅助功能。特别简单，但还算实用。</p> <h2>安装小助手</h2> <pre class="prettyprint"><code>$ [sudo] npm i -g weide </code></pre><h2>小助手用法</h2> <ul> <li>下载微信web开发者工具0.9(百度: <a href="https://pan.baidu.com/s/1pLxqFzH">https://pan.baidu.com/s/1pLxqFzH</a> （密码: bwt9）) 位置 /Applications/微信web开发者工具.app/</li> <li>下载微信web开发者工具0.7(百度: <a href="https://pan.baidu.com/s/1pLTKIqJ">https://pan.baidu.com/s/1pLTKIqJ</a> （密码: iswg）) 位置 /Applications/微信web开发者工具0.7.app/</li> </ul> <p>如果开发工具安装目录是/Applications/微信web开发者工具.app/，无需配置，一条命令即可</p> <pre class="prettyprint"><code>$ weide </code></pre><p>否则需要配置环境变量</p> <p>mac</p> <pre class="prettyprint"><code>$ export WECHAT_IDE=&#x2F;Applications&#x2F;微信web开发者工具0.9.app&#x2F; $ weide </code></pre><p>windows cmd</p> <pre class="prettyprint"><code>$ set WECHAT_IDE=&#x2F;Applications&#x2F;微信web开发者工具0.9.app&#x2F; $ weide </code></pre><h2>项目创建</h2> <p>用法部分来自老郭 <a href="http://www.geek-zoo.com">http://www.geek-zoo.com</a></p> <ol> <li>运行『微信Web开发者工具』</li> <li>通过微信扫描二维码</li> <li>创建项目</li> </ol> <ul> <li>AppID：随便填</li> <li>项目名称：随便填</li> <li>本地开发目录：选择一个目录</li> </ul> <ol> <li>点击「添加项目」</li> </ol> <ul> <li>此时如果出错，先退出再重进</li> <li>此时，能够看到项目列表了</li> </ul> <ol> <li>打开项目</li> <li>开始开发</li> <li>Good luck</li> </ol> <h2>学习资料</h2> <ul> <li>NoteDown版本 <ul> <li>框架入门 <ul> <li><a href="http://wxopen.notedown.cn/framework/MINA.html">http://wxopen.notedown.cn/framework/MINA.html</a></li> </ul> </li> <li>组件入门 <ul> <li><a href="http://wxopen.notedown.cn/component/">http://wxopen.notedown.cn/component/</a></li> </ul> </li> <li>API入门 <ul> <li><a href="http://wxopen.notedown.cn/api/">http://wxopen.notedown.cn/api/</a></li> </ul> </li> </ul> </li> </ul> <h2>Demo运行</h2> <ul> <li>创建项目</li> <li>打开项目所在目录</li> <li>下载「Demo源代码」并解压覆盖</li> <li>打开项目</li> <li>Good luck</li> </ul> <h2>常见问题</h2> <ol> <li>找不到所要替换的文件</li> </ol> <ul> <li>问题原因：开发工具版本不正确，老版本不支持</li> <li>解决方案：确保下载的程序版本在0.9.092100以上</li> </ul> <ol> <li>Failed to load resource: net::ERR_NAME_NOT_RESOLVED <a href="http://1709827360.appservice.open.weixin.qq.com/appservice">http://1709827360.appservice.open.weixin.qq.com/appservice</a></li> </ol> <ul> <li>问题原因：通常是由于系统设置了代理如Shadowsocks等。</li> <li>解决方案：关闭代理，或者依次点击工具栏“动作”-“设置”，选择“不使用任何代理，勾选后直连网络”。</li> </ul> <ol> <li>修复asdebug.js报错</li> </ol> <ul> <li>问题原因：TypeError: Cannot read property ‘MaxRequestConcurrent’ of undefined</li> <li>解决方案：替换 /Resources/app.nw/app/dist/weapp/appservice/asdebug.js</li> </ul> <ol> <li>扫码登录失败</li> </ol> <ul> <li>问题原因：please bind your wechat account to the appid first</li> <li>解决方案：先使用0.7版本的进行扫码登陆，登陆成功后，再用0.9的版本打开就直接进入了。 <ul> <li>0.7版本地址：<a href="http://dldir1.qq.com/WechatWebDev/release/0.7.0/wechat_web_devtools_0.7.0.dmg">http://dldir1.qq.com/WechatWebDev/release/0.7.0/wechat_web_devtools_0.7.0.dmg</a></li> </ul> </li> </ul> <ol> <li>mac版本升级到0.9.092300后，asdebug.js报错</li> </ol> <ul> <li>问题原因：TypeError: Cannot read property ‘MaxRequestConcurrent’ of undefined</li> <li>解决方案：替换 /Resources/app.nw/app/dist/weapp/appservice/asdebug.js</li> </ul> <h2>工具截图</h2> <p><img src="https://cloud.githubusercontent.com/assets/876707/18745196/f4f0488e-80f3-11e6-844b-f45d7e52a23c.png" alt="IDE"></p> <p><img src="https://cloud.githubusercontent.com/assets/876707/18745200/f7a74870-80f3-11e6-83cf-df00f7f87f56.png" alt="IDE"></p> <h2>禁用自动升级</h2> <p>破解之后，微信官方立马2个通宵，修复了大量问题，包括store命名错误，自动升级。可以说之前的版本是没有被特意“保护”的，所以可以挖出更多细节，nw.js的升级机制很简单，非常容易破解</p> <pre class="prettyprint"><code>$ wecrack </code></pre><p>会修改Contents/Resources/app.nw/package.json的版本号，避免自动升级</p> <h2>一键美化压缩js代码</h2> <p>会读取默认安装位置，或环境变量里的WECHAT_IDE下的所有js都会美化</p> <pre class="prettyprint"><code>$ allb </code></pre><h2>调试</h2> <pre class="prettyprint"><code>$ DEBUG=weide weide </code></pre><h2>更多</h2> <p>官方的IDE是nw.js + react写的，代码组织的还是相当不错的，如果大家想看，以后我们可以单独分享</p> </div>",
title: "微信应用号官方IDE破解助手，可避免自动升级",
last_reply_at: "2016-09-27T03:25:51.753Z",
good: false,
top: false,
reply_count: 1,
visit_count: 188,
create_at: "2016-09-27T01:07:13.100Z",
author: {
loginname: "i5ting",
avatar_url: "https://avatars.githubusercontent.com/u/3118295?v=3&s=120"
}
},
{
id: "55a5db26c78869230fab8de9",
author_id: "53be3c03a3ccaece73ba0606",
tab: "ask",
content: "<div class="markdown-text"><p>麻烦谁解释下这个东西是干什么用的？ 或是在那里能看到文档也可以， 找了很久也没找到这个函数的资料.</p> <p>谢谢各位哥哥姐姐</p> </div>",
title: "Error.captureStackTrace",
last_reply_at: "2016-09-27T03:18:30.312Z",
good: false,
top: false,
reply_count: 7,
visit_count: 1172,
create_at: "2015-07-15T04:01:42.226Z",
author: {
loginname: "danielsss",
avatar_url: "https://avatars.githubusercontent.com/u/5127897?v=3&s=120"
}
},
{
id: "562adf63004756b058c237b1",
author_id: "5583bf3b01d3ce0d73d68ef8",
tab: "share",
content: "<div class="markdown-text"><p>最近使用到手机短信校验，分享一下我的实现方式，也希望能够了解更好的实现方式 <img src="//dn-cnode.qbox.me/FjW0RDJHWj262RRUvycmeirPbSIc" alt="屏幕快照 2015-10-24 上午9.01.51.png"> 使用短信平台：阿里大鱼（阿里巴巴） 使用语言：node.js 数据库：redis（可用任意数据库或文件操作替代） 实现代码如下：</p> <pre class="prettyprint language-js"><code>&#x2F;&#x2F;安装依赖 &#x2F;&#x2F;redis 数据库操作模块 npm install redis &#x2F;&#x2F;taobao API 操作模块。ES6请使用topapi-node npm install top </code></pre><pre class="prettyprint language-js"><code>&#x2F;&#x2F;AuthController var redisClient = require(&#x27;..&#x2F;bin&#x2F;redisClient&#x27;); var regx = &#x2F;^(13|15|17|18|14)[0-9]{9}$&#x2F;; var top = require(&quot;top&quot;); var client = top.createClient({ appkey:&#x27;******&#x27;, appsecret:&#x27;*******&#x27;, REST_URL: &#x27;http:&#x2F;&#x2F;gw.api.taobao.com&#x2F;router&#x2F;rest&#x27; }); var params_check = { extend:&quot;&quot;, sms_type:&quot;normal&quot;, sms_free_sign_name:&quot;注册验证&quot;, sms_param:&#x27;{&quot;product&quot;:&quot;网站名&quot;,&quot;code&quot;:&quot;&#x27;+parseInt(code)+&#x27;&quot;}&#x27;, rec_num:tel, sms_template_code:&quot;SMS_1020033&quot; }; module.exports = { &#x2F;** * 发送短信验证 * @param req * @param res *&#x2F; &quot;smsCheck&quot;:function(req,res){ var tel = req.query.tel; if (!tel || !regx.exec(tel))return res.json({errMsg: &quot;tel is no true&quot;, errCode: &quot;400&quot;}); &#x2F;&#x2F;生成4位数字的随机数 var code = Math.floor(Math.random() * (9999 - 999 + 1) + 999); &#x2F;&#x2F;检查用户是否已经注册 User.findOne({tel: tel}).exec(function findOneCB(err, user) { if (user) return res.json({errMsg: &quot;该手机号已被注册&quot;, errCode: &quot;400&quot;}); redisClient.exists(&quot;register:&quot; + tel, function (err, result) { if (err)return res.json({errMsg: &quot;服务器出错，请重试&quot;, errCode: &quot;500&quot;}); if (result == 1)return res.json({errMsg: &quot;请求过于频繁，请稍候重试&quot;, errCode: &quot;423&quot;}); &#x2F;&#x2F;发送短信 client.invoke(&#x27;alibaba.aliqin.fc.sms.num.send&#x27;, params_check, [], null, &#x27;GET&#x27;, function (err, result) { if (!err) { &#x2F;&#x2F;发送成功 redisClient.multi() &#x2F;&#x2F;限制访问频率60秒 .set(&quot;register:&quot; + tel, code) .expire(&quot;register:&quot; + tel, 60) .hset(&quot;code:&quot; + tel, &quot;code&quot;,code) .hset(&quot;code:&quot; + tel,&quot;count&quot;,0) .exec(function (err, replies) { if (!err)return res.json({errMsg: &quot;ok&quot;, errCode: 0}); }); } else { res.json({errMsg: &quot;服务器出错，请重试&quot;, errCode: &quot;500&quot;}); } }); }); }); }, &#x2F;** * 检验验证码 * @param req * @param res *&#x2F; &quot;checkRandom&quot;:function(req,res){ var code = req.body.code; var tel = req.body.tel; redisClient.hgetall(&quot;code:&quot;+tel,function(err,result){ if (err)return res.status(500).json({errMsg:&quot;服务器出错，请重试&quot;,errCode:&quot;500&quot;}); &#x2F;&#x2F;服务器不存在校验码或已被删除 if(!result)return res.status(400).json({errMsg:&quot;验证码失效，请重新获取验证码&quot;,errCode:&quot;404&quot;}); if(result.code == code){ return res.status(200).json({errMsg:&quot;ok&quot;,errCode:&quot;0&quot;}); }else if(result.code != code){ if(result.count &gt;=100)redisClient.del(&quot;code:&quot; + tel); else redisClient.hset(&quot;code:&quot; + tel,&quot;count&quot;,Number(result.count)+1); return res.status(400).json({errMsg:&quot;验证码不一致&quot;,errCode:&quot;1&quot;}); } }); }, &#x2F;** * 提交注册 *&#x2F; &quot;register&quot;:function(req,res){ var data = req.body; if(!data || !data.tel ||!data.password || !data.code || !regx.exec(data.tel))return res.json({errMsg:&quot;请输入有效内容&quot;,errCode:&quot;400&quot;}); redisClient.get(&quot;code:&quot;+data.tel,function(err,result){ if (err)return res.json({errMsg:&quot;服务器出错，请重试&quot;,errCode:&quot;500&quot;}); if(result != data.code) return res.json({errMsg:&quot;验证码不一致&quot;,errCode:&quot;1&quot;}); &#x2F;&#x2F;通过短信校验 var user = { tel:data.tel, password:data.password }; User.create(user).exec(function createCB(err,createUser){ if(err){ return res.json({errMsg:&quot;服务器出错，创建失败&quot;,errCode:500}); } if(!err){ req.session.objectid = createUser.id; return res.json({errMsg:&quot;ok&quot;,errCode:0}); } &#x2F;&#x2F;清除缓存数据 redisClient.del(&quot;code:&quot;+data.tel); }); }); } }; </code></pre></div>",
title: "短信验证模块",
last_reply_at: "2016-09-27T03:14:07.073Z",
good: false,
top: false,
reply_count: 7,
visit_count: 1370,
create_at: "2015-10-24T01:31:15.955Z",
author: {
loginname: "welchwsy",
avatar_url: "https://avatars.githubusercontent.com/u/11153910?v=3&s=120"
}
},
{
id: "560cf75b1f6dc88c04049ae5",
author_id: "545870576537f4d52c414eb6",
tab: "share",
content: "<div class="markdown-text"><p>有Github账户的，大家互粉下吧， 大家可以跟帖，发上自己的 Github账户，我们互粉下，以后方便分享，自己的账户也有面子哈。 我的：<a href="https://github.com/pangguoming">https://github.com/pangguoming</a></p> </div>",
title: "有Github账户的，大家互粉下吧， 我的：https://github.com/pangguoming",
last_reply_at: "2016-09-27T03:05:37.263Z",
good: false,
top: false,
reply_count: 38,
visit_count: 2141,
create_at: "2015-10-01T09:05:31.136Z",
author: {
loginname: "pangguoming",
avatar_url: "https://avatars.githubusercontent.com/u/7269202?v=3&s=120"
}
},
{
id: "57e8fc69dd8ec6065642f363",
author_id: "51d37c80d44cbfa304285441",
tab: "share",
content: "<div class="markdown-text"><p>最近开始了完全node的全栈，遇到很多的问题，很多的感想和想法。 一步一步克服难题的感觉真的很不错，了解学习到的东西越多，就越想再学更多了解更多。 随着年龄的增长也想认识更多同行的人，想了解别人的团队是怎样，自己的团队该怎么优化。别人的项目是怎么管理，开发的流程，规范又是怎样？这些问题对于偏宅类生物－－程序猿都是有点难开展。 曾一度幻想家楼下的咖啡厅是一个聚集牛人，大咖，每天晚上一群怀着梦想的人在那畅谈分享的地方。</p> <p>so，参加一些讲座什么的，大多都是简单的介绍，蜻蜓点水似的，听完整个几个小时过去了也只是说一些你也知道的初级东西。你平时项目遇到的，真实的问题，难题依然还是个谜。</p> <p>想有一个线下的交流平台，一个固定的地方，一个可以让每个来的人尽可能得到他心里想要的答案的交流学习的地方。</p> <ul> <li>有问题可以有人像公司在带你的大神那样指导你。</li> <li>有想法可以有人和你一起聊给你意见甚至资源。</li> <li>让你的学习曲线尽可能的低。</li> <li>也同时教育你不要单单的只想获取，给机会你去分享帮助指导。</li> <li>不是几百人的一个大课堂，而是10个人左右的深入探讨</li> </ul> <p><strong>有人知道深圳哪里有这样的地方吗？</strong></p> <p>如果没有的话，本人一直是这么一个信念：没有的东西，想办法去创造。</p> <p>本人虽然不是什么大咖，牛人。但也有些经验可能可以帮助到别人。 和同学一起自创的团队，5年来一直负责项目管理，需求分析，功能设计，界面设计，开发现实。除了服务器不管，全部都做了。每天都有各种新奇的想法，但是基于时间和精力的问题无法实现。想让这些想法遇到可以让它落地的人～</p> <p>现在想到的模式是，每天（这个看多小人参与）根据收集到的想了解的东西定一个主题（全栈，不限定只是开发），邀约相关的有同样或者类似问题的人参与，组织方也尽量的邀约有这方面经验的人来参与，人数限定10个人左右，或者更小。尽可能保证质量而不是数量，参与的费用自理（基本就是自己的餐饮费吧）。有时候是想法分享会，参与者一起分析，设计给意见，如果需要的话，也会想办法帮忙找老板或者团队来买单（这样也是后话吧，先弄几次大家看看怎样再说～）</p> <p>深圳的IT气氛最好的是在南山，但是很多人因为种种问题不一定就在南山就业生活，我也是其中一个。so，更想服务于在罗湖、福田的有想法的人。 有这方面兴趣或者想法的欢迎一起交流。</p> <p>Email ： <a href="mailto:thomas_0836@qq.com">thomas_0836@qq.com</a> wechat: thomas_0836</p> </div>",
title: "深圳的全栈技术研讨会",
last_reply_at: "2016-09-27T02:55:57.970Z",
good: false,
top: false,
reply_count: 6,
visit_count: 165,
create_at: "2016-09-26T10:46:01.575Z",
author: {
loginname: "thomas0836",
avatar_url: "//gravatar.com/avatar/b62fb4edd06b28eb30c575af5fed1c61?size=48"
}
},
{
id: "57368a2e8f82e08e531de71a",
author_id: "5736887732bf2c90579f5330",
tab: "ask",
content: "<div class="markdown-text"><p>我用mocha做浏览器的单元测试，用到了chai断言库，npm install chai 添加模块后，&lt;script src="chai.js" type="text/javascript"&gt;&lt;/script&gt; 这个chai.js是怎么来的，能够直接 从chai模块中调到吗？还是说有个专门的chai.js 需要下载下来？</p> </div>",
title: "chai断言库在浏览器端怎么加载啊",
last_reply_at: "2016-09-27T02:25:34.858Z",
good: false,
top: false,
reply_count: 1,
visit_count: 436,
create_at: "2016-05-14T02:15:10.315Z",
author: {
loginname: "haiboli",
avatar_url: "https://avatars.githubusercontent.com/u/14259178?v=3&s=120"
}
},
{
id: "579c5a0b23e454cd2af8178f",
author_id: "57060f438a612c5559d16cdb",
tab: "ask",
content: "<div class="markdown-text"><p>似乎没在官网上找到说明</p> </div>",
title: "chai.should() 与 should.js 之间是什么关系？",
last_reply_at: "2016-09-27T02:17:45.186Z",
good: false,
top: false,
reply_count: 1,
visit_count: 386,
create_at: "2016-07-30T07:40:59.411Z",
author: {
loginname: "viko16",
avatar_url: "https://avatars.githubusercontent.com/u/5064777?v=3&s=120"
}
},
{
id: "57d8ca46b11d78e3659db4f9",
author_id: "563f17d0b0cedafd38970462",
tab: "share",
content: "<div class="markdown-text"><h2>前言</h2> <p>人的懒惰常常是麻烦的开始。多数程序员都希望自己的工作一劳永逸，一次开发，到处使用，成了人人追逐的目标，我也不例外。最初写《Nodejs开发加密货币》系列文章，因为不喜欢设定好了去写，所以目录反复修改，索性弄了小工具<code>gitbook-summary</code>；在写入门文章的时候，反复搜索github，索性把检索与制图集成到一起，弄了个开发语言检索统计工具（见《Node.js让您的前端开发像子弹飞一样》文章实例）；阅读源码的时候，手动整理Uml图很辛苦，干脆写成了js2uml工具（见《轻松从Js文件生成UML类图》文章实例）。这里是另一个例子，不过不是辅助写作的，而是简化web开发的，希望以后用起来方便点，也是懒惰的成果之一。接下来还会有，与本书写作有关，也与亿书项目有关的一个，就是可视化部署（在部署部分介绍）。与这些小工具相比，亿书算作其中相对较大的项目了。这些工具提高了我的工作效率，但也无形中增加了很多工作量。</p> <p>一个问题的解决，往往孕育着另一个问题的诞生，所以，只要写作和工作不断，与之相关的开发也就不会断。还好，除了个别情况下有点压力，我始终是享受其中的。但是，作为一个完整的有点规模的项目，明确的开发原则和开发路线图，还是必要的。其中一个重要的原则，就是保证每个功能要尽量独立，尽量做到可以重用。这不仅方便项目管理，也方便代码维护，所以，一次开发，处处可用，应该体现在每个环节。这种思想，促使我非常喜欢选择那种，稳固的、约束性较强的软件产品或开发平台，比如ruby on rails, Ember等开发框架。一旦学会，可以让我“一劳永逸”的按照一种思维逻辑去思考和解决遇到的问题。但也有聪明的小伙伴，更喜欢自己具有强大的自主控制权，这样的框架可能就不太适合他。</p> <p>无论什么样的框架产品，如果一个框架，虽然强大，但是会拒很多现有的工具于门外，必然不会被大家所接受。Ember约束性较强，属于我个人爱好，最初的版本对已有开发包的兼容性较差，但是现在做了很大改进，具备很好的扩展能力，本文就结合<code>ember-cli-fullpagejs</code>插件的开发过程，介绍Ember-cli插件开发的各个细节，看看把一个第三方库打包成一个小小的组件是多么简单。</p> <h2>插件简介</h2> <p>样式可以浏览亿书官网，<a href="http://ebookchain.org">http://ebookchain.org</a>，或参考《静态网站开发全景扫描》的截图。</p> <p>（1）源码</p> <p><a href="https://github.com/imfly/ember-cli-fullpagejs">https://github.com/imfly/ember-cli-fullpagejs</a></p> <p>（2）使用</p> <p>安装使用命令</p> <pre class="prettyprint"><code>$ npm install ember-cli-fullpagejs --save-dev </code></pre><p>然后，只要在模板文件里，使用标签 <code>{{#full-page}}{{/full-page}}</code> 代替 <code>&lt;div id=&quot;fullpage&quot;&gt;&lt;/div&gt;</code>即可， 其他与使用 fullPage.js 一样。</p> <p><strong>必须的 HTML 结构</strong></p> <pre class="prettyprint"><code>{{#full-page}} &lt;div class=&quot;section&quot;&gt;Some section&lt;&#x2F;div&gt; &lt;div class=&quot;section&quot;&gt;Some section&lt;&#x2F;div&gt; &lt;div class=&quot;section&quot;&gt;Some section&lt;&#x2F;div&gt; &lt;div class=&quot;section&quot;&gt;Some section&lt;&#x2F;div&gt; {{&#x2F;full-page}} </code></pre><p>为了在一个区域里创建滑块，每个滑块默认使用包含 slide 类的元素：</p> <pre class="prettyprint"><code>&lt;div class=&quot;section&quot;&gt; &lt;div class=&quot;slide&quot;&gt; Slide 1 &lt;&#x2F;div&gt; &lt;div class=&quot;slide&quot;&gt; Slide 2 &lt;&#x2F;div&gt; &lt;div class=&quot;slide&quot;&gt; Slide 3 &lt;&#x2F;div&gt; &lt;div class=&quot;slide&quot;&gt; Slide 4 &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; </code></pre><p><strong>选项</strong></p> <p>可以给标签直接添加选项，如:</p> <pre class="prettyprint language-html"><code>{{#full-page autoScrolling=&#x27;true&#x27; navigation=&#x27;true&#x27; anchors=&#x27;[&quot;firstPage&quot;, &quot;secondPage&quot;]&#x27; }} {{&#x2F;full-page}} </code></pre><p><strong>注意</strong>: 选项值必须使用单引号，而不是双引号。所有选项如下, <a href="https://github.com/alvarotrigo/fullPage.js#options">更多请参考</a>:</p> <h2>概念解读</h2> <p>（1）约定优于配置(convention over configuration)</p> <p>我们在《静态网站开发全景扫描》里简单罗列了Ember的几个注意点，特别提到约定优于配置的问题，这是导致很多小伙伴入手困难的根源。有人很奇怪，这是大家纷纷提倡的，本来是好事，怎么就成了问题了呢？是的，如果习惯了（其实就是记牢了）约定，开发难度会大大降低，效率大大提高，因为框架本身已经帮你做好了这一切。相反，记不住那么多约定，或者你根本就不知道其中有这样的约定，就会给你带来很多困扰。这是目前，我们在学习很多所谓的框架知识的时候，应该特别注意的。这类框架，之所以学习成本较高，一方面是因为规则太多，另一方面就是规则与我们固有的习惯冲突太多。</p> <p>举个简单的例子，我们在使用第三方库的时候，比如下面例子里的“fullPage.js”，通常要使用&lt;script&gt;&lt;/script&gt;标签来引入，接着按照该库的逻辑去做就是了。但作为一个约束较强的前端框架，类似的工作，你要先考虑一下，是不是有了它自己的规则。事实上，在Ember框架之下，正确的使用方法是先在<code>index.js</code>文件里使用<code>app.import</code>引入文件，然后使用组件的生命周期（见参考），通过合适的钩子方法来处理，这里是<code>didInsertElement()</code>方法。如果仍然延续原来的做法，最好的情况是得不到任何结果，最差的情况是得出奇怪的结果。</p> <p>这就给我们使用现有的第三方库造成了很大困难，原本大量现成的好工具，使用起来如此蹩脚。很多小伙伴因此，直接放弃了Ember，转投其他约束较少的框架去了。这里，我们不去衡量框架的优劣，还是直接考虑如何解决这点小问题吧。这个小例子可以帮助我们把现有的库直接改造成Ember可用的插件，让其融入Ember体系，降低绑定难度。因为插件开发的过程，与实际的开发有很多相似的地方，只不过多了一些简单的配置过程，所以我们就把具体的开发过程融入这个插件开发里一起介绍了。当然，这样做不足以介绍Ember的方方面面，至少会解决我认为最困扰我们的地方，降低Ember开发难度。</p> <p>（2）浏览器世界里的组件</p> <p>Ember的组件（Component）是非常重要的概念，特别是v2.0.0版本之后，全部取代了视图（View），可以理解为Ember的一切都是组件。一切都是组件的概念，大大简化了问题逻辑，也与浏览器保持了最大兼容性，甚至可以兼容未来的浏览器标准。我个人觉得，Ember团队从此终于走出了ruby on rails的桎梏，开始回归理性，真正面向前端了。毕竟把所有功能集中到一个浏览器页面里（单页面应用），还要硬生生的拉上MVC来，着实让开发者纠结不已。</p> <p>我们可以把浏览器最原始的按钮、链接、下拉框等标签元素，当成Ember最基本的组件来理解。有了Ember，就可以把一篇文章、一个列表、一个图片展示区域处理成一个组件，这样做至少有三个好处：一是，开发符合MVC的要求，可以做到数据与模板分离，就像开发一个独立的页面一样，思路清晰，快速高效；二是，使用上，这个组件本身与浏览器的基础组件没有区别，非常简单直接，可以自由组合嵌套；三是，一次开发，任何地方都可使用，甚至兼容未来的浏览器。</p> <p>大家看官方文档，还能看到控制器（Controller）和模型（Model）的概念，其实它们是另类的组件而已，可以理解为组件的扩展。如此以来，使用Ember就简化为浏览器组件的开发，而且使用Ember开发的组件功能也更加强大，使用与浏览器普通的组件没有分别，这样无论开发还是使用都极度简化了。如果再把今天的这个例子弄明白，基本上，我们可以把任何重复性的功能都包装成各种组件，然后打包成插件，需要的时候，直接把这些插件安装上，就可以随处可用了，就又达到了一劳永逸的效果。</p> <h2>开发过程</h2> <p>现在，我们就来看看 ember-cli-fullpagejs 的完整开发过程吧。</p> <h4>插件基本情况</h4> <p>（1）场景</p> <p>Ember CLI插件API，当前支持下面的场景:</p> <ul> <li>通过<code>ember-cli-build.js</code>操作<code>EmberApp</code>（主应用）</li> <li>添加预处理器到默认的注册表</li> <li>提供一个自定义应用程序树与应用程序合并</li> <li>提供定制的专用(服务)中间件</li> <li>添加自定义模板，为主程序生成相关的工程文件</li> </ul> <p>（2）命令行选项</p> <p>Ember CLI有一个 <em>addon</em> 命令，带有下面的选项:</p> <pre class="prettyprint language-bash"><code>ember addon &lt;addon-name&gt; &lt;options...&gt; Creates a new folder and runs ember init in it. --dry-run (Default: false) --verbose (Default: false) --blueprint (Default: addon) --skip-npm (Default: false) --skip-bower (Default: false) --skip-git (Default: false) </code></pre><p>注意：一个插件不会在已经存在的应用程序中被创建</p> <p>（3）创建插件</p> <p>创建一个基本插件:</p> <p><code>ember addon &lt;addon-name&gt;</code></p> <p>运行该命令，就会产生下面这些文件：</p> <pre class="prettyprint language-bash"><code>$ ember addon fullpagejs version x.y.zz installing create .bowerrc create .editorconfig create tests&#x2F;dummy&#x2F;.jshintrc ... create index.js Installing packages for tooling via npm Installed browser packages via Bower. </code></pre><h4>插件工程结构</h4> <p>通过上述命令，自动生成插件工程目录和相关文件，插件工程遵循这些结构约定:</p> <ul> <li><code>app/</code> - 合并到应用程序的命名空间(意思是说，在使用该插件的应用程序里，可以直接使用)。</li> <li><code>addon/</code> - 插件的命名空间部分。</li> <li><code>blueprints/</code> - 包含插件所有蓝图模板文件，每一个存放在一个独立的文件夹里。</li> <li><code>public/</code> - 应用程序使用的静态文件，css，images，fonts等，路径前缀 <code>/your-addon/*</code></li> <li><code>test-support/</code> - 合并到应用程序的<code>tests/</code></li> <li><code>tests/</code> - 测试文件夹，包括一个&quot;dummy&quot;测试应用和验收测试助手。</li> <li><code>vendor/</code> - 第三方专有文件，比如stylesheets, fonts, 外部包等等。</li> <li><code>ember-cli-build.js</code> - 编译设置。</li> <li><code>package.json</code> - Node.js元数据，依赖库等。</li> <li><code>index.js</code> - Node.js入口(遵从npm约定)。</li> </ul> <p>（1）Package.json</p> <p>插件的<code>package.json</code>文件，像这样:</p> <pre class="prettyprint language-javascript"><code>{ &quot;name&quot;: &quot;ember-cli-fullpagejs&quot;, &#x2F;&#x2F; 插件名称 &quot;version&quot;: &quot;0.0.1&quot;, &#x2F;&#x2F; 插件版本 &quot;directories&quot;: { &quot;doc&quot;: &quot;doc&quot;, &quot;test&quot;: &quot;test&quot; }, &quot;scripts&quot;: { &quot;start&quot;: &quot;ember server&quot;, &quot;build&quot;: &quot;ember build&quot;, &quot;test&quot;: &quot;ember test&quot; }, &quot;repository&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;repo-user&#x2F;my-addon&quot;, &quot;engines&quot;: { &quot;node&quot;: &quot;&gt;= 0.10.0&quot; }, &quot;keywords&quot;: [ &quot;ember-addon&quot; &#x2F;&#x2F; 添加更多关键字，便于分类插件 ], &quot;ember-addon&quot;: { &#x2F;&#x2F; 插件配置属性 &quot;configPath&quot;: &quot;tests&#x2F;dummy&#x2F;config&quot; }, &quot;author&quot;: &quot;&quot;, &#x2F;&#x2F; 你的名字 &quot;license&quot;: &quot;MIT&quot;, &#x2F;&#x2F; 协议 &quot;devDependencies&quot;: { &quot;body-parser&quot;: &quot;^1.2.0&quot;, ... &#x2F;&#x2F; 在这里添加专门的依赖库! } } </code></pre><p>Ember CLI将通过检测每个应用的依赖包的<code>package.json</code>文件，看在<code>keywords</code>部分是否有<code>ember-addon</code>关键字，从而检查一个插件是否存在。我们还可以添加一些额外的元数据来更好地分类该插件:</p> <pre class="prettyprint language-javascript"><code> &quot;keywords&quot;: [ &quot;ember-addon&quot;, &quot;fullpagejs&quot;, &quot;fullpage.js&quot; ], </code></pre><p>（2）插件入口</p> <p>所谓的插件入口，就是调用插件最先执行的文件，每种编程语言都需要。插件将利用npm约定，并寻找一个 <code>index.js</code> 文件作为入口点，除非通过<code>package.json</code>文件的<code>&quot;main&quot;</code>属性指定另一个入口点。建议使用<code>index.js</code>作为插件入口点。</p> <p>产生的<code>index.js</code>文件是一个简单的js对象(POJO) ，可以定制和扩展，像这样：</p> <pre class="prettyprint language-javascript"><code>&#x2F;&#x2F; index.js module.exports = { name: &#x27;ember-cli-fullpagejs&#x27;, included: function(app, parentAddon) { var target = (parentAddon || app); &#x2F;&#x2F; 这里你可以修改主应用（app） &#x2F; 父插件（parentAddon）. 比如, 如果你想包括 &#x2F;&#x2F; 一个定制的执行器，你可以把它加到目标注册器，如： &#x2F;&#x2F; target.registry.add(&#x27;js&#x27;, myPreprocessor); } }; </code></pre><p>在构建（build）过程中，included钩子方法会被执行，直接操作主应用程序或者它的父插件，提高插件的处理能力。这个对象扩展了<code>Addon</code>类，所以任何存在于<code>Addon</code>类的钩子方法都可以被重写。请参考《Ember的几个重要钩子方法简介》</p> <h4>插件开发设计</h4> <p>（1）添加插件依赖</p> <p>这里，我们把要封装的第三方包<code>fullpagejs</code>作为插件的依赖包，打包进插件里去。安装客户端依赖要通过’Bower’:</p> <pre class="prettyprint"><code>bower install --save-dev fullpagejs </code></pre><p>上述命令，自动添加bower组件到开发依赖</p> <pre class="prettyprint language-javascript"><code>&#x2F;&#x2F; bower.js { &quot;name&quot;: &quot;ember-cli-fullpagejs&quot;, &quot;dependencies&quot;: { ... &quot;fullpage.js&quot;: &quot;^2.7.8&quot; } } </code></pre><p>（2）定制组件</p> <p>我们要把fullpage.js定制成为一个普通的浏览器组件，希望可以这么使用它：</p> <pre class="prettyprint language-html"><code>{{#full-page autoScrolling=&#x27;true&#x27; navigation=&#x27;true&#x27; }} {{&#x2F;full-page}} </code></pre><p>先生成组件，可以使用下面的命令：</p> <pre class="prettyprint"><code>$ ember generate component full-page </code></pre><p>组件名称至少有一个“-”线，这是约定，请记住。这个命令会自动生成必要的文件，以及测试文件，只要在里面添加逻辑代码就是了。为了允许应用程序不用手动导入语句而使用插件组件，应该把组件放在应用程序的命名空间之下，即<code>app/components</code>目录下，上面的命令已经帮你自动生成，如下：</p> <pre class="prettyprint language-javascriptc"><code>&#x2F;&#x2F; app&#x2F;components&#x2F;full-page.js export { default } from &#x27;ember-cli-fullpagejs&#x2F;components&#x2F;full-page&#x27;; </code></pre><p>这行代码从插件路径导入组件，再导出到应用程序。实际组件的代码放在<code>addon/components/full-page.js</code>里：</p> <pre class="prettyprint language-javascript"><code>import Ember from &#x27;ember&#x27;; export default Ember.Component.extend({ tagName: &#x27;div&#x27;, &#x2F;&#x2F; 这里的选项与fullPage.js包的选项是一致的，请参考：https:&#x2F;&#x2F;github.com&#x2F;alvarotrigo&#x2F;fullPage.js#options options: { &#x2F;&#x2F;Navigation menu: &#x27;#menu&#x27;, lockAnchors: false, ... }, didRender() { Ember.run.scheduleOnce(&#x27;afterRender&#x27;, this, function() { var options = clone(this, this.options); Ember.$(&quot;#fullpage&quot;).fullpage(options); }); }, willDestroyElement() { Ember.$.fn.fullpage.destroy(&#x27;all&#x27;); } }); </code></pre><p>Ember的组件渲染之后的标签，默认为<code>&lt;div&gt;&lt;/div&gt;</code>，所以如果需要改为其他的标签，比如span，可以定义tabName属性来重写。didRender()和willDestroyElement()是两个钩子方法，属于组件生命周期的一部分，前者将在组件静态内容全部渲染之后执行，起到了$(document).ready()方法的作用，所以可以确保Ember.$(&quot;#fullpage&quot;)元素存在的时候执行；后者，将在元素销毁（通常是页面刷新的时候）的时候执行，因为Ember是一个单页面应用，无论你如何跳转或刷新，全局变量Ember.$始终保持，所以必须手动清理。</p> <p>这里的问题是，为什么使用didRender()，而不是didInsertElement()钩子方法？你看看官方提供的钩子方法文档就知道了，前者在页面初始渲染以及再次渲染（刷新）的时候都可用，而后者仅在初始渲染的时候使用。也就是说，前者可以保证刷新页面，也能保证效果，后者则只能在加载页面时有效果，这也是约定好的。</p> <p>这里还需要重点解释的是，这个组件也按照“约束优于配置”的原理进行了处理。比如：默认被<code>{{#full-page }}</code> 标签包围的代码，会被包裹在<code>&lt;div id=&quot;fullpage&quot;&gt;&lt;/div&gt;</code>里，这就避免了用户忘记设置id，而导致出现错误。另外，对选项（options）的处理，默认选项都放在了属性 <code>options</code> 之下了，但是我们却可以在使用中去重写，比如 <code>{{#full-page autoScrolling='true' navigation='true' }}</code>，这里就使用了ember对组件的一种默认处理，即：写在组件标签里的选项，自动成为该组件对象的属性，因此<code>autoScrolling</code>和<code>navigation</code>自然就成为<code>full-page</code>组件的属性之一，然后我自定义clone方法，把它们重写到<code>options</code>就是了。看代码很简单，但却隐含了诸多知识点，也是文档没有直接提供的。</p> <h4>加载第三方库</h4> <p>（1）默认蓝图模板</p> <p>所谓的蓝图模板，就是我们在安装插件的时候，应该如何把js或css文件加载到主程序，这就好比是第三方库的下载。比如本例，我们在安装插件的使用应该把fullpage.js下载到主程序里。为创建蓝图模板, 添加一个文件 <code>blueprints/ember-cli-fullpagejs/index.js</code>，这是标准的Ember蓝图模板的命名约定。</p> <pre class="prettyprint language-javascript"><code>module.exports = { description: &#x27;ember-cli-fullpagejs&#x27;, normalizeEntityName: function() { &#x2F;&#x2F; allows us to run ember -g ember-cli-fullpagejs and not blow up &#x2F;&#x2F; because ember cli normally expects the format &#x2F;&#x2F; ember generate &lt;entitiyName&gt; &lt;blueprint&gt; }, afterInstall: function(options) { return this.addBowerPackageToProject(&#x27;fullpage.js&#x27;, &#x27;^2.7.8&#x27;); } }; </code></pre><p>（2）加载库文件</p> <p>然后，我们就可以把它导入到主应用程序了，需要在<code>index.js</code>文件里，使用<code>included</code>钩子以正确的顺序导入这些文件，如下：</p> <pre class="prettyprint language-javascript"><code>&#x2F;&#x2F;index.js module.exports = { name: &#x27;ember-cli-fullpagejs&#x27;, included: function included(app) { this._super.included(app); &#x2F;&#x2F; workaround for https:&#x2F;&#x2F;github.com&#x2F;ember-cli&#x2F;ember-cli&#x2F;issues&#x2F;3718 if (typeof app.import !== &#x27;function&#x27; &amp;&amp; app.app) { app = app.app; } var fullpagejsPath = path.join(app.bowerDirectory, &#x27;fullpage.js&#x2F;dist&#x27;); app.import(path.join(fullpagejsPath, &#x27;jquery.fullpage.min.css&#x27;)); app.import(path.join(fullpagejsPath, &#x27;jquery.fullpage.min.css.map&#x27;), { destDir: &#x27;assets&#x27; }); app.import(path.join(fullpagejsPath, &#x27;jquery.fullpage.min.js&#x27;)); app.import(path.join(fullpagejsPath, &#x27;jquery.fullpage.min.js.map&#x27;), { destDir: &#x27;assets&#x27; }); } }; </code></pre><p>这一步就相当于我们平常使用的<code>&lt;script&gt;&lt;/script&gt;</code>标签，不过这里的好处是，可以直接压缩打包进主程序。</p> <p>（3）导入静态文件</p> <p>图片、字体等静态文件，通常放在<code>/public</code>文件夹里，比如有一张图片，可以保存在 <code>your-addon/public/images/foo.png</code>路径下，使用的时候，这样调用：</p> <pre class="prettyprint"><code>.foo {background: url(&quot;&#x2F;your-addon&#x2F;images&#x2F;foo.png&quot;);} </code></pre><p>（4）高级定制</p> <p>一般来说，如果超越内置或想要/需要更高级的控制，以下是<code>index.js</code>里一些插件对象的可用钩子(键)。所有的钩子都希望把一个函数作为它的值（钩子都应该是函数）。</p> <pre class="prettyprint language-javascript"><code>includedCommands: function() {}, blueprintsPath: &#x2F;&#x2F; return path as String preBuild: postBuild: treeFor: contentFor: included: postprocessTree: serverMiddleware: lintTree: </code></pre><p>比如，这里的<code>contentFor</code>钩子方法，可以在主程序index.html里，含有<code>{{content-for &quot;header&quot;}}</code>标签的地方插入对应内容。</p> <h4>测试插件</h4> <p>插件工程包含一个<code>/tests</code> 文件夹，该文件夹包含运行和设置插件测试的基本文件。<code>/tests</code> 文件夹有下面的结构:</p> <ul> <li><code>/dummy</code></li> <li><code>/helpers</code></li> <li><code>/unit</code></li> <li><code>index.html</code></li> <li><code>test_helper.js</code></li> </ul> <p><code>/dummy</code> 文件夹包含一个基本的dummy应用，用于测试插件。</p> <p><code>/helpers</code> 文件夹包含各类<em>qunit</em>助手，包括为了保持测试简洁，而自定义的。</p> <p><code>/unit</code> 文件夹包含单元测试，用以测试插件用于各种可用场景。</p> <p><code>integration/</code> 文件夹包含是集成测试。</p> <p><code>test_helper.js</code> 是应该在任何测试文件中引用的主要帮助文件，它导入了<code>resolver</code>助手，可以在<code>/helpers</code>文件夹中找到，用于解析<code>dummy</code>中的页面。</p> <p><code>index.html</code>包含浏览器中加载的测试页面，以显示运行单元测试的结果。</p> <p>对于如何设置和运行测试，请看官方文档，我们也会用一篇文章专门讲述。</p> <h4>蓝图模板</h4> <p>蓝图模板是一些具有可选安装逻辑的模板文件。它用于根据一些参数和选项生成特定的应用程序文件。一个插件可以有一个或多个蓝图模板。</p> <p>（1）创建蓝图模板</p> <p>给插件创建一个<em>blueprint</em>:</p> <p><code>ember addon &lt;blueprint-name&gt; --blueprint</code></p> <p>按照惯例，插件的主要蓝图模板应该具有与插件相同的名称:</p> <p><code>ember addon &lt;addon-name&gt; --blueprint</code></p> <p>在我们的例子中，使用命令:</p> <p><code>ember addon fullpagejs --blueprint</code></p> <p>这将为插件产生一个文件夹 <code>blueprints/ember-cli-fullpagejs</code>，在这里可以定义蓝图模板的逻辑和模板文件。可以为一个插件定义多个蓝图模板。最后加载的蓝图模板会覆盖现有(同名的)蓝图模板，该模板可以是来自Ember或其他插件(根据包加载顺序)</p> <p>（2）蓝图模板约定</p> <p>蓝图模板应该放在插件根目录的<code>blueprints</code>文件夹下，就像覆盖工程根目录的蓝图模板一样。如果把它们放在插件的其他目录下，需要通过设置插件的<code>blueprintsPath</code>属性告诉ember-cli去哪找到它 (请看下面的 <em>高级定制</em> 部分)，如果熟悉 <em>Yeoman</em> (或Rails)的产生器，蓝图模板遵从类似的约定和结构。要想更深入的了解蓝图模板设计，请看 <a href="https://github.com/stefanpenner/ember-cli/tree/master/blueprints">Ember CLI blueprints</a>。</p> <p>（3）模板文件结构</p> <pre class="prettyprint language-bash"><code>blueprints&#x2F; fullpagejs&#x2F; index.js files&#x2F; app&#x2F; components&#x2F; __name__&#x2F; unbutton index.js files&#x2F; config&#x2F; __name__.js </code></pre><p>注：这里被命名为<code>__name__</code> 的特殊文件或文件夹，将（在运行命令时）在主应用程序中产生一个文件/文件夹，并用第一个命令行参数(name)代替<code>__name__</code>。</p> <p>`ember g fullpagejs my-button``</p> <p>由此在主应用程序中产生一个文件夹<code>app/components/my-button</code>。</p> <h4>辅助工具</h4> <p>（1）开发时链接插件</p> <p>当开发和测试的时候，可以在插件工程的根目录运行<code>npm link</code>，这样就可以通过插件名称在本地使用该插件了。然后，在计划使用的应用程序工程根目录，运行<code>npm link &lt;addon-name&gt;</code>，就会将插件链接到应用程序的<code>node_modules</code>文件夹下，并添加到<code>package.json</code>文件。这样，插件中的任何改变都会在链接该插件的任何工程中直接发生作用。</p> <p>需要注意的是，<code>npm link</code>不会像使用安装命令时那样运行默认的蓝图模板（也就是不会调用钩子方法，下载或生成相关的库文件），需要手动使用<code>ember g</code>来处理。另外，当我们使用这种链接的方式测试插件的时候，要提供合法的版本信息<code>&quot;&lt;addon-name&gt;&quot;:&quot;version&quot;</code>，后面的version可以使用<code>*</code>代替，而且旧版本的npm可能需要手动添加到<code>package.json</code>。</p> <p>（2）发布插件</p> <p>使用 <em>npm</em> 和 <em>git</em> 来发布插件，就像一个标准的npm包。</p> <pre class="prettyprint language-bash"><code>npm version 0.0.1 git push origin master git push origin --tags npm publish </code></pre><p>这些命令将被执行：</p> <ul> <li>使用版本号标签版本（tag）</li> <li>推送提交的插件代码到版本库(origin branch)</li> <li>推送新标签到版本库(origin branch)</li> <li>发布插件到全局npm库</li> </ul> <p>（3）安装和使用插件</p> <p>为了在主应用中使用插件，使用下面的命令安装该插件：</p> <p><code>npm install ember-cli-&lt;your-addon-name-here&gt; --save-dev</code>.</p> <p>对于我们的 <em>fullpagejs</em> 插件，这样使用：</p> <p><code>npm install ember-cli-fullpagejs --save-dev</code>.</p> <p>运行 <em>fullpagejs</em> 蓝图模板：</p> <p><code>ember generate fullpagejs</code></p> <p>（4）更新插件</p> <p>可以像更新Ember应用一样，通过在工程根目录运行<code>ember init</code>命令，更新一个插件。</p> <h2>总结</h2> <p>这篇文章，通过实例详细描述了利用Ember框架，把一个第三方库封装为可以重用的组件的方法（当然，要在Ember框架之下使用），简化了第三方库的使用方法，为我们使用Ember扫除了一个障碍。但是，反过来，这篇文章可能不适合刚入门的小伙伴阅读和使用，因为大量基础知识，需要您去浏览官方文档去补充，然后结合本文，做深层次的思考。我本人觉得，Ember的目标和代码给了我很大的触动，确实适合做比较综合的大的项目，就像亿书这类应用，大部分功能将被集中到客户端里，所以用Ember开发将非常方便。但是这不代表您也可以选择，所以做自己喜欢、擅长和有价值的事情，才是成功的开端。</p> <h2>链接</h2> <p><strong>本系列文章即时更新，若要掌握最新内容，请关注下面的链接</strong></p> <p>本文地址： <a href="https://github.com/imfly/bitcoin-on-nodejs">https://github.com/imfly/bitcoin-on-nodejs</a></p> <h2>参考</h2> <ul> <li><a href="https://ember-cli.com/extending/#developing-addons-and-blueprints">developing addons and blueprints</a></li> <li><a href="https://guides.emberjs.com/v2.8.0/components/the-component-lifecycle/">组件的生命周期</a></li> <li><a href="https://github.com/alvarotrigo/fullPage.js">fullPage.js</a></li> <li><a href="https://ember-cli.com/api/classes/Addon.html">插件的钩子方法（hooks）文档</a></li> </ul> </div>",
title: "《Nodejs开发加密货币》之二十七：开发通用的HTML组件",
last_reply_at: "2016-09-27T02:06:46.971Z",
good: false,
top: false,
reply_count: 1,
visit_count: 259,
create_at: "2016-09-14T03:55:50.335Z",
author: {
loginname: "imfly",
avatar_url: "https://avatars.githubusercontent.com/u/12215508?v=3&s=120"
}
},
{
id: "57d581e6a183f0c13865c939",
author_id: "55683e40444bdaaa388e6b7f",
tab: "job",
content: "<div class="markdown-text"><h2>关于T社</h2> <p>从刚开始作为工人、水手的工作服，T恤因其舒适、透气、吸汗而受到人们欢迎。一部《欲望号街车》，让T恤走进了公众视野，随后逐渐风靡全球。</p> <p>T社是一个创想至上的T恤定制与预售平台，让热爱T恤的T迷们用自己的表达方式涂绘在T恤上面，做自己所爱，把喜欢穿在身上，把喜欢分享出去。T社平台从生产、配送及管理，帮助发起者实现无库存销售，让T恤定制变得更简单！</p> <p>目前公司近50人，包括3位创始人：</p> <ul> <li>CEO ，拥有丰富的人生阅历，辗转四国求学，适应力极强，吹过太平洋的风，踏过下雪的美国，混过大名鼎鼎的剑桥。归国后曾任顶级 VC 投资人，观察敏锐，经验老道，积累丰厚的互联网资源后，开始自己动手丰衣足食的创业生涯。心地善良的暖男 CEO ，主要给T社的小伙伴们做除了技术以外的任何活儿。</li> <li>CTO ，前IDG 自由人（青年驻场企业家），大学拿遍各种奖学金并环游世界，折腾 Facebook App 做到百万用户，热爱从零到一创造价值的感觉。毕业后加入外资投行开发顶级算法交易，业余时间不忘搭建各种产品，坚信技术改变世界。</li> <li>CSCO （供应链合伙人），国际贸易科班毕业，传统行业游侠，项目遍及服装、矿产、农产品、食品原材料及加工等，并对进出口和贸易、金融多有涉足。家族20年经营服饰面料，与几十家国内外品牌合作密切，品牌供应商资源硬朗。</li> </ul> <h2>招聘职位</h2> <h3>高级前端工程师（ 10~15K ）</h3> <p>要求</p> <ul> <li>本科及以上学历，至少两年开发工程师经验</li> <li>具备督导能力，有开发团队管理经验</li> <li>精通 JavaScript ，理解 JavaScript 的模块化和自动构建</li> <li>接触过至少一种 JavaScript 框架（如 React 、 Vue 、AngularJS 等）</li> <li>熟悉 CSS3/HTML5 ，对移动端 web 开发和浏览器兼容性有一定了解</li> <li>熟悉至少一种代码托管工具（ Git/SVN ）</li> </ul> <p>加分</p> <ul> <li>有 Nodejs 开发经验</li> <li>在线作品、博客，或开源项目开发经验</li> <li>对产品、交互有自己独到的见解</li> </ul> <h3>实习开发工程师（ 2~3K ）</h3> <p>要求</p> <ul> <li>熟悉至少一门编程语言（如 Nodejs / Ruby / Java / Python 等），有良好的编程功底。</li> <li>了解SQL语言，接触过关系型数据库，如 MySQL、Postgresql 等。有Web开发经验者优先。</li> <li>2017年毕业的在校学生，计算机相关专业本科及以上学历。</li> <li>实习期保证3个月以上，一周不少于4天的工作时间。</li> </ul> <p>加分</p> <ul> <li>在线作品、博客，或开源项目开发经验</li> <li>使用过至少一种代码托管工具（ Git/SVN ）</li> <li>熟悉 Linux / Unix 命令行</li> <li>有极客精神，热爱编程，对自己的代码有追求</li> <li>看英文文档学新技术无压力</li> </ul> <h2>公司福利</h2> <ul> <li>有竞争力的薪资</li> <li>13 薪，培训福利，浮动年终奖</li> <li>早期员工，不错的期权激励</li> <li>午餐、晚餐补贴</li> <li>完善的薪酬体系，每年的薪资晋级和职位提升机会</li> <li>良好的工作环境，免费零食饮料，更有下午茶、 T社欢乐趴等活动</li> <li>满一年享受 5 天年假，年假假期将逐年增加</li> <li>弹性上班时间， 09:00 – 10:00 为上班时间，下班时间为 18:00 – 19:00</li> <li>生日红包、大乐透及生日蛋糕让你的生日不再寂寞</li> <li>不定期组织员工旅游、户外休闲等活动，外出旅行、真人 CS 、别墅派对等</li> </ul> <h2>技术栈</h2> <p>T社技术团队均来自国内外顶尖学府及互联网公司，我们玩技术、爱技术、不妥协。</p> <ul> <li>后端： Nodejs/Ruby On Rails + Docker</li> <li>前端： React + Redux, Vue，Nodejs, Webpack</li> <li>移动： React Native</li> <li>Code Review 、持续集成、持续部署和自动化测试，Github + Jenkins CI + Slack + Lint</li> <li>队内技术分享，定期的大牛分享</li> <li>喜欢技术挑战</li> </ul> <h2>新闻报道</h2> <p>T社是技术圈的好伙伴 。 Vue.js 、 Strikingly 、稀土掘金、 SegmentFault 等都是我们的合作伙伴。今年T社更是中国 JSConf、RubyConf 独家 T恤提供方。</p> <ul> <li>公司官网： <a href="https://www.tshe.com">https://www.tshe.com</a></li> <li>品牌视频： <a href="http://v.qq.com/boke/page/z/0/3/z0175jum2d3.html">http://v.qq.com/boke/page/z/0/3/z0175jum2d3.html</a></li> <li>36kr 报道： <a href="http://36kr.com/p/5040894.html?ref=head_line_top">http://36kr.com/p/5040894.html?ref=head_line_top</a></li> <li>铅笔道报道： <a href="http://qianbidao.baijia.baidu.com/article/260835">http://qianbidao.baijia.baidu.com/article/260835</a></li> <li>小饭桌报道： <a href="http://it.sohu.com/20160106/n433637711.shtml">http://it.sohu.com/20160106/n433637711.shtml</a></li> <li>创业邦报道： <a href="http://www.cyzone.cn/a/20160121/289004.html">http://www.cyzone.cn/a/20160121/289004.html</a></li> <li>T-Show ： <a href="https://www.tshe.com/stories">https://www.tshe.com/stories</a></li> </ul> <h2>联系我们</h2> <p>如果你对 T社感兴趣，欢迎发送简历到 <a href="mailto:hi@tshe.com">hi@tshe.com</a>。</p> </div>",
title: "[厦门] T 社招聘高级前端工程师和实习开发工程师",
last_reply_at: "2016-09-27T01:58:31.589Z",
good: false,
top: false,
reply_count: 1,
visit_count: 175,
create_at: "2016-09-11T16:10:14.666Z",
author: {
loginname: "citysheep",
avatar_url: "https://avatars.githubusercontent.com/u/526876?v=3&s=120"
}
},
{
id: "57e8afea1e1508eb554f2a14",
author_id: "541a99f78732411c771bc59b",
tab: "ask",
content: "<div class="markdown-text"><blockquote> <p><strong>NOTE</strong> When a $sort immediately precedes a $limit in the pipeline, the $sort operation only maintains the top n results as it progresses, where n is the specified limit, and MongoDB only needs to store n items in memory. This optimization still applies when allowDiskUse is true and the n items exceed the aggregation memory limit.</p> <p>Changed in version 2.4: Before MongoDB 2.4, $sort would sort all the results in memory, and then limit the results to n results.</p> </blockquote> <p>上文摘自 MongoDB 3.2.9 的官方文档。文中描述的意思是什么？</p> <pre class="prettyprint language-javascript"><code>query.sort({someField: 1}).limit(10); </code></pre><p>实际上是先取了 <code>10</code> 个记录，再排序这 <code>10</code> 条记录的吗？</p> </div>",
title: "关于 mongodb 的分页查询",
last_reply_at: "2016-09-27T01:56:55.735Z",
good: false,
top: false,
reply_count: 7,
visit_count: 202,
create_at: "2016-09-26T05:19:38.633Z",
author: {
loginname: "fiftyk",
avatar_url: "https://avatars.githubusercontent.com/u/1246010?v=3&s=120"
}
},
{
id: "57e966cd56898f231a526f8d",
author_id: "564b8a661986c7df7e92afc0",
tab: "ask",
content: "<div class="markdown-text"><blockquote> <p>显示npm ERR! No Space left on device</p> </blockquote> <p>我之前也有遇到，唯有办法就是删我的一些，但我觉得很麻烦，请还有其他的办法吗？ 我已经增加了ubuntu系统空间，但还是一样！</p> <p><img src="//dn-cnode.qbox.me/FpcMQaDbRPDLbcm2nrY0g_o3Dbhl" alt="untitled1.png"> <img src="//dn-cnode.qbox.me/Fs3xjR7CdwSMphLrEjo_w8KJwEEa" alt="untitled2.png"></p> </div>",
title: "关于npm内存不足的问题",
last_reply_at: "2016-09-27T01:13:39.269Z",
good: false,
top: false,
reply_count: 1,
visit_count: 87,
create_at: "2016-09-26T18:19:57.312Z",
author: {
loginname: "decadehew",
avatar_url: "https://avatars.githubusercontent.com/u/3433864?v=3&s=120"
}
},
{
id: "57e9b2fb0424cced19b35cb1",
author_id: "503a6618f767cc9a5104139c",
tab: "share",
content: "<div class="markdown-text"><h3>介绍</h3> <p>lockman 是一个用于多进程的并发控制锁， 类似一些语言中（比如 C#）的 lock 关键字可以用来确保代码块完成运行，而不会被其他进程「影响」。 它可以把一段代码定义为互斥段（critical section），互斥段在一个时刻内只允许一个进程进入执行， 而其他进程必须等待。</p> <p>不同之处，C# 的 lock 关键字作用在「线程间」，lockman 作用在 Node 的进程间。</p> <p><a href="http://badge.fury.io/js/lockman"><img src="https://badge.fury.io/js/lockman.svg" alt="npm version"></a> <a href="https://travis-ci.org/Houfeng/lockman"><img src="https://travis-ci.org/Houfeng/lockman.svg?branch=master" alt="Build Status"></a></p> <h3>安装</h3> <pre class="prettyprint language-sh"><code>$ npm install lockman --save </code></pre><h3>示例</h3> <pre class="prettyprint language-js"><code>const Locker = require(&#x27;lockman&#x27;); let locker = new Locker(&#x27;demo&#x27;); locker.acquire(function(){ &#x2F;&#x2F;此处代码在同一时刻只允许一个进程进入执行 locker.release(); }); </code></pre></div>",
title: "Node 多进程并发控制小模块 - lockman",
last_reply_at: "2016-09-26T23:44:59.931Z",
good: false,
top: false,
reply_count: 0,
visit_count: 126,
create_at: "2016-09-26T23:44:59.931Z",
author: {
loginname: "houfeng",
avatar_url: "//gravatar.com/avatar/4ccd30a6ccc36203b826a50047183ea6?size=48"
}
},
{
id: "57e9582256898f231a526f8c",
author_id: "57e94cce56898f231a526f8a",
tab: "share",
content: "<div class="markdown-text"><p>这是一个为了阅读复杂 JavaScript 代码而开发的工具，以阅读 Vue.js 为例，在 Sublime Text 中打开后感觉非常复杂，不知道该从哪里读起： <img src="//dn-cnode.qbox.me/FsRGwkjb2J-tHm_ifa8KhT6ikJuF" alt="Screen Shot 2016-09-27 at 00.55.50.png"></p> <p>使用 lambda-view 打开后，可以看到源代码整体的轮廓其实就是一个立即调用的匿名函数： <img src="//dn-cnode.qbox.me/Fq3zGJ2h504tTdoPCU2QZ3FGdziH" alt="Screen Shot 2016-09-27 at 00.46.19.png"></p> <p>展开函数部分，值得注意的缩进风格与 Sublime Text 之类的编辑器完全不同，更易读；并且内部结构默认处于收缩状态，可以比较清楚的看到整个函数内的轮廓： <img src="//dn-cnode.qbox.me/FjrjgoVugMMleW5lVkD4bK42TqGL" alt="Screen Shot 2016-09-27 at 00.47.14.png"></p> <p>点击后可以继续展开： <img src="//dn-cnode.qbox.me/FiKcf6ds1PvT89cK5KysJAdvJt6E" alt="Screen Shot 2016-09-27 at 00.47.34.png"></p> <p>不仅可以阅读 Vue.js 之类的前端代码，Node.js 代码也完全没问题。下面的截图来自 Node.js v4.5.0 源代码中的 node.js 文件，可以清晰的看到其整体结构也是一个立即调用的匿名函数： <img src="//dn-cnode.qbox.me/FpRnBkvscNQot1Muks87hiuJad-z" alt="Screen Shot 2016-09-27 at 01.11.10.png"></p> <p>展开后内部结构很清楚： <img src="//dn-cnode.qbox.me/FjAbcApkZ6iTc7GyeAajtu3cLe1n" alt="Screen Shot 2016-09-27 at 01.11.16.png"></p> <p>对于最新版本的 Node.js v6.5.0 （使用了 ES6 语法）也完全没问题，可以放心实验。该工具的安装使用方法参见项目主页：<a href="https://github.com/Jianru-Lin/lambda-view">https://github.com/Jianru-Lin/lambda-view</a></p> </div>",
title: "简化阅读复杂 JavaScript 代码难度的一个辅助工具 lambda-view",
last_reply_at: "2016-09-26T17:17:22.244Z",
good: false,
top: false,
reply_count: 0,
visit_count: 107,
create_at: "2016-09-26T17:17:22.244Z",
author: {
loginname: "Jianru-Lin",
avatar_url: "https://avatars.githubusercontent.com/u/1057486?v=3&s=120"
}
},
{
id: "57e7a15d2528eed904783f88",
author_id: "57dfc5587e77820e3acfe047",
tab: "ask",
content: "<div class="markdown-text"><p>这是我mongodb中存储的数据</p> <pre class="prettyprint language-javascript"><code>{ &quot;_id&quot; : ObjectId(&quot;4ec0b2a4ecb31ca1968000fd&quot;), &quot;id&quot; : 1001, &quot;singer&quot; : &quot;刘德华&quot;, &quot;someReview&quot; : [{ &quot;user&quot; : &quot;dong&quot;, &quot;text&quot; : &quot;不好听&quot; }, { &quot;user&quot; : &quot;wan&quot;, &quot;text&quot; : &quot;打酱油&quot; }, { &quot;user&quot; : &quot;wan&quot;, &quot;text&quot; : &quot;真的挺不错，一直很喜欢刘德华&quot; }] } </code></pre><p>我想通过查询得到</p> <pre class="prettyprint language-javascript"><code>{ &quot;_id&quot; : ObjectId(&quot;4ec0b2a4ecb31ca1968000fd&quot;), &quot;id&quot; : 1001, &quot;singer&quot; : &quot;刘德华&quot;, &quot;someReview&quot; : [{ &quot;user&quot; : &quot;dong&quot;, &quot;text&quot; : &quot;不好听&quot; }] } </code></pre><p>应该怎么写查询语句？也就是说我想查询user为“dong”条目，而不是全部的数组信息。</p> </div>",
title: "mongodb 数组查询",
last_reply_at: "2016-09-26T14:27:55.629Z",
good: false,
top: false,
reply_count: 6,
visit_count: 201,
create_at: "2016-09-25T10:05:17.076Z",
author: {
loginname: "youthfighter",
avatar_url: "https://avatars.githubusercontent.com/u/20010154?v=3&s=120"
}
}
]
}